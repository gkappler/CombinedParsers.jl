<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CombinedParsers.jl</title><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CombinedParsers.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Package-Features"><span>Package Features</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Useful-Design"><span>Useful Design</span></a></li><li><a class="tocitem" href="#Optimization-Strategy"><span>Optimization Strategy</span></a></li><li><a class="tocitem" href="#Acknowledgements"><span>Acknowledgements</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li><li class="toplevel"><a class="tocitem" href="#Contributing-and-Questions"><span>Contributing and Questions</span></a></li><li><a class="tocitem" href="#Outline"><span>Outline</span></a></li><li><a class="tocitem" href="#main-index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/guide/">Overview</a></li><li><a class="tocitem" href="man/user/">User Guide</a></li><li><a class="tocitem" href="man/example-either-trie/">Prefix-Tree Matching</a></li><li><a class="tocitem" href="man/pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="man/example-person/">What is Parsing? Names...</a></li><li><a class="tocitem" href="man/example-number-ranges/">Representations: Number sequences</a></li><li><a class="tocitem" href="man/pcre/">Regular Expressions</a></li><li><a class="tocitem" href="man/example-palindromes/">struct Palindrome&lt;:CombinedParser</a></li><li><a class="tocitem" href="man/example-arithmetics/">Arithmetics</a></li><li><a class="tocitem" href="man/json/">JSON</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public/">Public</a></li><li><a class="tocitem" href="lib/regexp/">Regexp</a></li><li><a class="tocitem" href="lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gkappler/CombinedParsers.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CombinedParsers.jl-Documentation"><a class="docs-heading-anchor" href="#CombinedParsers.jl-Documentation">CombinedParsers.jl Documentation</a><a id="CombinedParsers.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CombinedParsers.jl-Documentation" title="Permalink"></a></h1><p>A package for combining parsers and transforming strings into julia types.</p><p>Compose parsers parsimoneously within a functional <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator paradigm</a>, utilize Julia&#39;s type inference for transformations, log conveniently for debugging, and let Julia compile your parser for performance.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>CombinedParsers.jl</code> is currently a release candidate presented at JuliaCon2020. See the next steps section, if interested.</p></div></div><h2 id="Package-Features"><a class="docs-heading-anchor" href="#Package-Features">Package Features</a><a id="Package-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Features" title="Permalink"></a></h2><ul><li>Speed<ul><li><a href="man/pcre-compliance/">write parsers faster than <code>Base.PCRE</code></a>, optimized by the Julia compiler for parametric parser and state types.</li><li><code>@generated function</code>s, trie-based scanning (<a href="man/example-either-trie/">example</a>), compile with your custom parsing algorithm (<a href="man/example-palindromes/">example</a>)</li><li>(planned: memoization, lazy transformations)</li></ul></li><li>Simplicity<ul><li>Clear <a href="lib/public/#CombinedParsers.@syntax"><code>@syntax</code></a> integrates <a href="lib/public/#Base.map"><code>map</code></a> transformations with Julia <a href="lib/public/#CombinedParsers.result_type"><code>result_type</code></a> inference.</li><li>Define without redundancy: parser, memory representation, and instance construction. When solely the parser is defined, Julia infers <a href="lib/public/#CombinedParsers.result_type"><code>result_type</code></a>(parser) and defines memory layout,  and constructors are compiled for the parsing state from <a href="lib/internals/#CombinedParsers.Transformation"><code>Transformation</code></a>s.</li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees.jl</a> interface provides clearly layed out printing in the REPL. <a href="lib/public/#CombinedParsers.with_log"><code>with_log</code></a> provides colored logging of the parsing <a href="lib/public/#CombinedParsers.with_name"><code>with_name</code></a>s.</li></ul></li><li>Interoperability<ul><li><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a>: existing <code>TextParse.AbstractToken</code> implementations can be used with CombinedParsers. <code>CombinedParser</code> provide <code>TextParse.tryparsenext</code> and can be used e.g. in CSV.jl.</li><li>Pure Julia regular expression parsers are provided with the <a href="lib/public/#CombinedParsers.Regexp.@re_str"><code>@re_str</code></a> macro, a plug-in replacement for <code>Base.@r_str</code>. Tested on the <a href="man/pcre-compliance/">PCRE pattern test set</a>.</li></ul></li><li>Generality<ul><li>All valid parsings can be <a href="@ref"><code>Base.iterate</code></a>d lazily.</li><li>Higher-order parsers depending on the parsing state allow for not context-free parsers (<a href="@ref"><code>after</code></a>).</li><li>can process UTF8 strings or any sequence type supporting <code>getindex</code>, <code>nextind</code>, <code>prevind</code> methods.</li></ul></li></ul><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>The <a href="man/guide/#Overview">Overview</a> provides a tutorial explaining how to get started using CombinedParsers. The <a href="man/user/">User guide</a> provides a summary of CombinedParsers types and constructors. Some examples of packages using CombinedParsers can be found on the <a href="#Examples">Examples</a> page. See the <a href="#main-index">Index</a> for the complete list of documented functions and types.</p><blockquote><p><code>CombinedParsers.jl</code> is a registered package:</p></blockquote><p>Install with</p><pre><code class="language-julia">] add CombinedParsers</code></pre><h3 id="Example:-rational-numbers-arithmetics"><a class="docs-heading-anchor" href="#Example:-rational-numbers-arithmetics">Example: rational numbers arithmetics</a><a id="Example:-rational-numbers-arithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-rational-numbers-arithmetics" title="Permalink"></a></h3><p>Parsing is reading and transforming a sequence of characters. <code>CombinedParsers</code> provides constructors to combine parsers and transform (sub-)parsings arbitrarily with julia syntax.</p><pre><code class="language-julia">using CombinedParsers
using TextParse</code></pre><p>This example reads and evaluates arithmetical terms for rational numbers. The following defines an evaluating parser for rational number terms as sequences of subterms interleaved with operators.</p><p>Subterms are <a href="lib/public/#CombinedParsers.Either"><code>Either</code></a> integer numbers, <code>TextParse.Numeric(Int)</code> converted to <code>Rational{Int}</code>, or subterms are written as parentheses around a nested term:</p><pre><code class="language-julia">@syntax subterm = Either{Rational{Int}}(Any[TextParse.Numeric(Int)]);
@syntax for parenthesis in subterm
    mult         = evaluate |&gt; join(subterm, CharIn(&quot;*/&quot;), infix=:prefix )
    @syntax term = evaluate |&gt; join(mult,    CharIn(&quot;+-&quot;), infix=:prefix )
    Sequence(2,&#39;(&#39;,term,&#39;)&#39;)
end;</code></pre><p>The <a href="lib/public/#CombinedParsers.@syntax"><code>@syntax</code></a> definition in 5,5 lines is sufficient for parsing and evaluating arithmetics: <a href="lib/public/#Base.join"><code>Base.join</code></a><code>(x, delimiter; infix=:prefix)</code> is shorthand for <a href="lib/public/#CombinedParsers.Sequence"><code>Sequence</code></a><code>(x ,</code><a href="lib/public/#CombinedParsers.Repeat"><code>Repeat</code></a><code>( delimiter * x  ))</code>, and <code>f |&gt; parser</code> is shorthand for <a href="lib/public/#Base.map"><code>map</code></a><code>(f,parser)</code>. That&#39;s all! <a href="lib/public/#CombinedParsers.@syntax"><code>@syntax</code></a> registers a <code>@term_string</code> macro for parsing and transforming:</p><pre><code class="language-julia-repl">julia&gt; result_type(term)
Rational{Int64}

julia&gt; term&quot;(1+2)/5&quot;
3//5

julia&gt; # The defined `CombinedParser` `term` function
       # provides optional logging of the parsing process.
       term(&quot;1/((1+2)*4+3*(5*2))&quot;,log = [:parenthesis])
   match parenthesis@4-9: 1/((1+2)*4+3*(
                             ^___^
   match parenthesis@14-19: *4+3*(5*2))
                                 ^___^
   match parenthesis@3-20: 1/((1+2)*4+3*(5*2))
                             ^_______________^
1//42</code></pre><p><a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)">Is every rational answer ultimately the inverse of a universal question in life?</a></p><p>Note: The <code>evaluate</code> function definition is detailed in <a href="man/example-arithmetic.md">the full example</a>.</p><pre><code class="language-julia-repl">julia&gt; evaluate( (0, [ (&#39;+&#39;,1), (&#39;-&#39;,2) ]) )
-1//1

julia&gt; evaluate( (1, [ (&#39;*&#39;,4), (&#39;/&#39;,3) ]) )
4//3</code></pre><h2 id="Useful-Design"><a class="docs-heading-anchor" href="#Useful-Design">Useful Design</a><a id="Useful-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-Design" title="Permalink"></a></h2><ul><li><a href="https://github.com/gkappler/WikitextParser.jl">WikitextParser.jl</a> is a <code>CombinedParser</code> for parsing <a href="https://en.wikipedia.org/wiki/Help:Wikitext">wikitext syntax</a>, quite comprehensibly and representing Wikipedia articles within Julia.</li><li>OrgmodeParser.jl is a <code>CombinedParser</code> for parsing main <a href="https://orgmode.org/">org mode</a> syntax, representing org files within Julia.</li><li><a href="https://github.com/gkappler/CombinedParserTools.jl">CombinedParserTools.jl</a> is currently more or less my own workspace to provide a set of re-useable parsers, used in <code>WikitextParser</code>.</li><li><a href="https://github.com/gkappler/Tries.jl">Tries.jl</a> is the abstract implementation of the fast prefix-tree matching in <code>CombinedParsers</code> (see <a href="https://gkappler.github.io/CombinedParsers.jl/dev/man/example-either-trie/">docs</a>)</li></ul><p>If you want to work with any of these open source packages, I will gladly provide professional support. If you are writing your own recursive <code>CombinedParser</code> and seek inspiration, you might find these comprehensive examples interesting. (currently α release, so beware, dragons!)</p><p>The <code>CombinedParsers</code> design </p><ul><li>is fast due to Julia parametric types, and compiler optimizations with generated functions,</li><li>its strictly typed parsing defines the domain data types,</li><li>is composable and optimizable with Julia method dispatch,</li><li>provides flexible public API for parsing, matching, iteration</li></ul><p>Making Julia parametric types central for the parser design equally allows automation of the data pipeline after parsing.</p><p>FilingForest demonstrates indexing the German Wiktionary into a columnar database, with fast selecting and measuring. I am finishing the write-up of Wiktionary data parsing into a language graph database including:</p><ul><li>fast db-indexing of text streams (e.g. logging): If you need support indexing logging streams into a (SQL-)Database, the (currently) proprietary TypeGraphs.jl provides <code>CombinedParsers</code> plug and play: Table schemas are infered from your parser.</li><li>fast out-of core data science/AI on your parsed data: If you need support with storing parsed data in optimized memory-mapped JuliaDB, TypeDB.jl provides <code>CombinedParsers</code> plug and play. </li><li>fast scientific measurements in a data graph: FilingForest IA.jl provides <code>CombinedParsers</code> plug and play: even for recursively nested data.</li></ul><p>All (currently) proprietary packages are default-over-configuration for fast integration, and are in active development.</p><ul><li>fast HTTP-serving of parsed data: If you need support with a parsing server-client infrastructure, the (currently) proprietary GraphQLAlchemy.jl provides <code>CombinedParsers</code> plug and play: GraphQL schemas and resolver are infered from your parser.</li></ul><h2 id="Optimization-Strategy"><a class="docs-heading-anchor" href="#Optimization-Strategy">Optimization Strategy</a><a id="Optimization-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Strategy" title="Permalink"></a></h2><p>With the C PCRE2 library testset, and for 58% of patterns, <code>CombinedParsers</code>  match faster than <code>Regex</code> (first 100 pattern). C PCRE2 optimized is among the fastest regex libraries (<a href="https://github.com/mariomka/regex-benchmark/tree/optimized">second behind Rust</a>, running <a href="https://github.com/mariomka">mariomka</a>&#39;s benchmark will position CombinedParser among its competition). Explorations for optimization are in git branches.</p><blockquote><p>All benchmarks are wrong, but some are useful - <a href="https://github.com/szilard">Szilard</a>, <a href="https://github.com/szilard/benchm-ml">benchm-ml</a></p></blockquote><ul><li><a href="man/pcre-compliance/#Compliance-with-the-PCRE-test-set">Compliance with the PCRE test set</a></li><ul><li><a href="man/pcre-compliance/#Test-Overview">Test Overview</a></li><ul><li><a href="man/pcre-compliance/#Performance-Overview:">Performance Overview:</a></li><li><a href="man/pcre-compliance/#Benchmark-ratios-histogram:">Benchmark ratios histogram:</a></li></ul><li><a href="man/pcre-compliance/#Unsupported">Unsupported</a></li></ul></ul><p>The package is still young, and optimization is ongoing. If you are interested in and able to dive deeper into the Julia memory layout and compiler, I would gladly collaborate on further optimizations:</p><ul><li>String layout: Parsing requires repeated Char comparisons. In UTF8, frequent characters are encoded shorter (8 bit), rare have longer codes. For this reason, in Julia <code>String</code> indices are not consecutive and transversal requires using infamous <code>nextind</code> and <code>prevind</code>. Profiling:<ul><li><code>nextind</code> and <code>prevind</code> comsume considerable time.  Could be cached/memoized?</li><li><code>CombinedParsers</code> currently operates on the result of <code>getindex(::String,index)::Char</code> (technically on <code>iterate(::String,index)::Tuple{Char,Int}</code>).  Could matching use the raw byte representation directly?</li></ul></li><li>Macros: make all iteration <code>@generated</code> functions using expressions generated by a dispatched <code>iterate_expression</code> that can be used in a macro <code>@iterate</code> to generate an unrolled/unnested iteration code. (Profiling hints that function calls do hardly contribute to runtime.)</li></ul><h2 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h2><p>This package is enabled only due to the Julia&#39;s compiler and superior type system. Thankfully: a really concise language for powerful computing!</p><p>I am thankful for contributions and inspiration from many great packages:</p><h3 id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a class="docs-heading-anchor" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a></a><a id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)" title="Permalink"></a></h3><blockquote><p>A bunch of fast text parsing tools, used in CSV.jl</p></blockquote><p><code>CombinedParsers</code> composes with fast <a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a> both ways  because <code>CombinedParser &lt;: TextParse.AbstractToken</code> and by providing a method for <code>TextParse.tryparsenext</code>, (leveraging the supreme Julia compiler, type and package architecture).</p><ul><li>If you seek support with a dates parser example, please contact me.</li><li>If you seek support with a CSV example, please contact me (e.g. address text field parsing).</li></ul><article class="docstring"><header><a class="docstring-binding" id="Dates.tryparsenext" href="#Dates.tryparsenext"><code>Dates.tryparsenext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">TextParse.tryparsenext(x::CombinedParser,str,i,till,opts=TextParse.default_opts)</code></pre><p>TextParse.jl integrates with CombinedParsers.jl both ways.</p><pre><code class="language-">DocTestFilters = r&quot;map\(.+\)&quot;</code></pre><pre><code class="language-julia-repl">
julia&gt; p = (&quot;Number:&quot; * Repeat(&#39; &#39;) * TextParse.Numeric(Int))[3]
🗄 Sequence |&gt; map(IndexAt(3))
├─ Number\:
├─ \ *  |&gt; Repeat
└─ &lt;Int64&gt;
::Int64

julia&gt; parse(p, &quot;Number:    42&quot;)
42

julia&gt; TextParse.tryparsenext(p, &quot;Number:    42&quot;)
(Nullable{Int64}(42), 14)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/5c910d67637b588c6cd5ccd7378d9f8322eef3f0/src/textparse.jl#LL3-L28">source</a></section></article><h3 id="Inspirations"><a class="docs-heading-anchor" href="#Inspirations">Inspirations</a><a id="Inspirations-1"></a><a class="docs-heading-anchor-permalink" href="#Inspirations" title="Permalink"></a></h3><ul><li>The work was strongly inspired by the great Scala <a href="https://github.com/lihaoyi/fastparse">fastparse</a> package, and also the <a href="https://package.elm-lang.org/packages/elm/parser/latest/">elm parser</a>.</li><li><a href="https://github.com/JuliaData/Parsers.jl">Parsers.jl</a>, a collection of parsers for date and primitive types, inspired the <a href="lib/public/#Base.parse"><code>parse</code></a> methods.</li><li><a href="https://github.com/BioJulia/Automa.jl">Automa.jl</a>, a Julia package for text validation, parsing, and tokenizing based on state machine compiler.  The package compiles deterministic finite automata.  (Currently there is no inter-operation possible, because in <code>Automa</code> processing of parsed tokens is done with actions and UTF8 support is lacking).</li><li><a href="https://github.com/andrewcooke/ParserCombinator.jl">ParserCombinator.jl</a> was a great inspiration. Yet I decided for a new design with a focus on transformations and type inference with parametric types, instead of basing this work off <code>ParserCombinator</code>, written before 2016 (and fixed for Julia 1.0 in 2018). <code>CombinedParsers</code> integrates into the Julia 1.0 Iteration API, small <code>Union{Nothing,T} where T</code> types instead of using Nullables, compiler optimizations and generated functions. I want to provide benchmarks comparisons with <code>ParserCombinator.jl</code>.</li></ul><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><ul><li>[ ] Syntax freeze – your comments are appreciated!</li><li>[ ] decide for a error tracing strategy, backtracking. If you want to collaborate on stepping &amp; debugging, please reach out to me.</li><li>[ ] Performance optimizations</li><li>[ ] streaming</li><li>[ ] test coverage underestimated (PCRE tests are not included in travis)</li><li>[ ] <a href="https://github.com/invenia/BlueStyle"><img src="https://img.shields.io/badge/code%20style-blue-4495d1.svg" alt="Code Style: Blue"/></a></li></ul><h1 id="Contributing-and-Questions"><a class="docs-heading-anchor" href="#Contributing-and-Questions">Contributing and Questions</a><a id="Contributing-and-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing-and-Questions" title="Permalink"></a></h1><p>Contributions and feedback are very welcome,  especially regarding brief syntax and constructor dispatch.  Please open an issue if you encounter any problems or would just like to ask a question, or contact me at mail@g-kappler.de.</p><h2 id="Outline"><a class="docs-heading-anchor" href="#Outline">Outline</a><a id="Outline-1"></a><a class="docs-heading-anchor-permalink" href="#Outline" title="Permalink"></a></h2><h3 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h3><ul><li><a href="man/guide/#Overview">Overview</a></li><ul><li><a href="man/guide/#ParseMatch"><code>ParseMatch</code></a></li><li><a href="man/guide/#Parsing">Parsing</a></li><li><a href="man/guide/#Iterating">Iterating</a></li><li><a href="man/guide/#Performance">Performance</a></li><li><a href="man/guide/#Transformations">Transformations</a></li></ul><li><a href="man/user/#User-Guide">User Guide</a></li><ul><li><a href="man/user/#Basics">Basics</a></li><li><a href="man/user/#Character-Sets">Character Sets</a></li><li><a href="man/user/#Sequence">Sequence</a></li><li><a href="man/user/#Either">Either</a></li><li><a href="man/user/#Repeat">Repeat</a></li><li><a href="man/user/#Optional">Optional</a></li><li><a href="man/user/#Lazy-repetitions-and-optional-parsers">Lazy repetitions and optional parsers</a></li><li><a href="man/user/#Assertions">Assertions</a></li><li><a href="man/user/#AtStart()-and-AtEnd()">AtStart() and AtEnd()</a></li><ul><li><a href="man/user/#Looking-around">Looking around</a></li></ul><li><a href="man/user/#Atomic-groups">Atomic groups</a></li></ul><li><a href="man/example-either-trie/#A-fast-[Trie](https://github.com/gkappler/Tries.jl)-based-parser-for-a-collection-of-literal-Strings.">A fast Trie-based parser for a collection of literal Strings.</a></li><ul><ul><li><a href="man/example-either-trie/#Next-steps">Next steps</a></li></ul></ul></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li><a href="man/example-person/#What-is-Parsing?">What is Parsing?</a></li><ul><li><a href="man/example-person/#Names">Names</a></li><li><a href="man/example-person/#Addresses">Addresses</a></li><li><a href="man/example-person/#Person&#39;s-address-data">Person&#39;s address data</a></li></ul><li><a href="man/example-number-ranges/#Number-lists-(wikitext-references)">Number lists (wikitext references)</a></li><ul><li><a href="man/example-number-ranges/#Number-ranges">Number ranges</a></li><li><a href="man/example-number-ranges/#Numbers">Numbers</a></li><li><a href="man/example-number-ranges/#Joining-numbers-and-ranges">Joining numbers and ranges</a></li><li><a href="man/example-number-ranges/#Inclusion-in-a-wikitext-parser">Inclusion in a wikitext parser</a></li><li><a href="man/example-number-ranges/#PCRE-papercuts-when-parsing-number-sequences">PCRE papercuts when parsing number sequences</a></li></ul><li><a href="man/pcre/#Regular-Expressions-[CombinedParser](@ref)">Regular Expressions <code>CombinedParser</code></a></li><ul><li><a href="man/pcre/#What-is-a-regular-expression?">What is a regular expression?</a></li><li><a href="man/pcre/#Characters-and-Escaped-Characters">Characters and Escaped Characters</a></li><li><a href="man/pcre/#Repeated-patterns">Repeated patterns</a></li><ul><li><a href="man/pcre/#Number-of-Repetitions:-Transforming-a-Parsing">Number of Repetitions: Transforming a Parsing</a></li></ul><li><a href="man/pcre/#[Either](@ref)"><code>Either</code></a></li><li><a href="man/pcre/#Repeatable-patterns,-[Optional](@ref),-[Lazy](@ref)-and-[Atomic](@ref)">Repeatable patterns, <code>Optional</code>, <code>Lazy</code> and <code>Atomic</code></a></li><li><a href="man/pcre/#[Sequence](@ref)s-and-Alternations"><code>Sequence</code>s and Alternations</a></li><li><a href="man/pcre/#[Capture](@ref)s"><code>Capture</code>s</a></li><li><a href="man/pcre/#[Lookahead](@ref)-and-[Lookbehind](@ref)"><code>Lookahead</code> and <code>Lookbehind</code></a></li><li><a href="man/pcre/#Regular-Expression-Brackets">Regular Expression Brackets</a></li></ul><li><a href="man/example-palindromes/#Palindromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser"><code>Palindromes&lt;:CombinedParser</code>: a Tutorial for writing your combinable Parser</a></li><ul><li><a href="man/example-palindromes/#.-Regular-Expression">1. Regular Expression</a></li><ul><li><a href="man/example-palindromes/#Tree-display-of-regex">Tree display of regex</a></li><li><a href="man/example-palindromes/#Regular-Expression-performance">Regular Expression performance</a></li></ul><li><a href="man/example-palindromes/#.-A-non-word-skipping-Palindrome:CombinedParser">2. A non-word skipping <code>Palindrome&lt;:CombinedParser</code></a></li><ul><li><a href="man/example-palindromes/#Parsing-strategy">Parsing strategy</a></li><ul><li><a href="man/example-palindromes/#Prerequisite:-Skipping-whitespace">Prerequisite: Skipping whitespace</a></li></ul><li><a href="man/example-palindromes/#Subtyping-:-CombinedParser{STATE,RESULT}.">Subtyping <code>&lt;: CombinedParser{STATE,RESULT}</code>.</a></li><li><a href="man/example-palindromes/#Matching:-CombinedParsers._iterate">Matching: <code>CombinedParsers._iterate</code></a></li><li><a href="man/example-palindromes/#Base.prevind-and-Base.nextind"><code>Base.prevind</code> and <code>Base.nextind</code></a></li><li><a href="man/example-palindromes/#match-and-get"><code>match</code> and <code>get</code></a></li><li><a href="man/example-palindromes/#Iterating-through-matches">Iterating through matches</a></li><ul><li><a href="man/example-palindromes/#Iteration-of-smaller-Sub-palindromes">Iteration of smaller Sub-palindromes</a></li></ul><li><a href="man/example-palindromes/#Performance-Optimization">Performance Optimization</a></li><li><a href="man/example-palindromes/#Padding-and-combining">Padding and combining</a></li></ul><li><a href="man/example-palindromes/#Next...">Next...</a></li></ul><li><a href="man/json/#JSON">JSON</a></li></ul><h3 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h3><ul><li><a href="lib/public/#Public-Documentation">Public Documentation</a></li><ul><li><a href="lib/public/#Matching">Matching</a></li><ul><li><a href="lib/public/#Parsing">Parsing</a></li></ul><li><a href="lib/public/#Typed-Transformation-Parsers">Typed Transformation Parsers</a></li><li><a href="lib/public/#Parser-Constructors">Parser Constructors</a></li><ul><li><a href="lib/public/#useful-importable-sub-parsers">useful importable sub-parsers</a></li><li><a href="lib/public/#Character-Matchers">Character Matchers</a></li><li><a href="lib/public/#Combining-Parser">Combining Parser</a></li><li><a href="lib/public/#Repeating">Repeating</a></li><li><a href="lib/public/#Logging-and-Side-Effects">Logging and Side-Effects</a></li><li><a href="lib/public/#Assertions">Assertions</a></li></ul></ul><li><a href="lib/internals/#Internal-API">Internal API</a></li><ul><li><a href="lib/internals/#Iterating-Parsings">Iterating Parsings</a></li></ul><li><a href="lib/internals/#Internal-Types">Internal Types</a></li><ul><li><a href="lib/internals/#Abstract-Parsers">Abstract Parsers</a></li><li><a href="lib/internals/#Wrapped-Parsers">Wrapped Parsers</a></li><li><a href="lib/internals/#States">States</a></li><li><a href="lib/internals/#Printing">Printing</a></li><li><a href="lib/internals/#Rewriting-Parsers">Rewriting Parsers</a></li></ul></ul><h2 id="main-index"><a class="docs-heading-anchor" href="#main-index">Index</a><a id="main-index-1"></a><a class="docs-heading-anchor-permalink" href="#main-index" title="Permalink"></a></h2><ul><li><a href="lib/public/#CombinedParsers.Lookahead"><code>CombinedParsers.Lookahead</code></a></li><li><a href="lib/public/#CombinedParsers.Lookbehind"><code>CombinedParsers.Lookbehind</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat1"><code>CombinedParsers.Repeat1</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat_stop"><code>CombinedParsers.Repeat_stop</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat_until"><code>CombinedParsers.Repeat_until</code></a></li><li><a href="lib/public/#CombinedParsers.log_names"><code>CombinedParsers.log_names</code></a></li><li><a href="lib/public/#CombinedParsers.parser"><code>CombinedParsers.parser</code></a></li><li><a href="lib/public/#CombinedParsers.result_type"><code>CombinedParsers.result_type</code></a></li><li><a href="lib/public/#CombinedParsers.sEither"><code>CombinedParsers.sEither</code></a></li><li><a href="lib/public/#CombinedParsers.sSequence"><code>CombinedParsers.sSequence</code></a></li><li><a href="lib/public/#CombinedParsers.state_type"><code>CombinedParsers.state_type</code></a></li><li><a href="lib/public/#CombinedParsers.tryparse_pos"><code>CombinedParsers.tryparse_pos</code></a></li><li><a href="lib/public/#CombinedParsers.with_effect"><code>CombinedParsers.with_effect</code></a></li><li><a href="lib/public/#CombinedParsers.with_log"><code>CombinedParsers.with_log</code></a></li><li><a href="lib/public/#CombinedParsers.with_name"><code>CombinedParsers.with_name</code></a></li><li><a href="lib/public/#CombinedParsers.Always"><code>CombinedParsers.Always</code></a></li><li><a href="lib/public/#CombinedParsers.AnyChar"><code>CombinedParsers.AnyChar</code></a></li><li><a href="lib/public/#CombinedParsers.AtEnd"><code>CombinedParsers.AtEnd</code></a></li><li><a href="lib/public/#CombinedParsers.AtStart"><code>CombinedParsers.AtStart</code></a></li><li><a href="lib/public/#CombinedParsers.Atomic"><code>CombinedParsers.Atomic</code></a></li><li><a href="lib/public/#CombinedParsers.CharIn"><code>CombinedParsers.CharIn</code></a></li><li><a href="lib/public/#CombinedParsers.CharNotIn"><code>CombinedParsers.CharNotIn</code></a></li><li><a href="lib/public/#CombinedParsers.Constant"><code>CombinedParsers.Constant</code></a></li><li><a href="lib/public/#CombinedParsers.Either"><code>CombinedParsers.Either</code></a></li><li><a href="lib/public/#CombinedParsers.JoinSubstring"><code>CombinedParsers.JoinSubstring</code></a></li><li><a href="lib/public/#CombinedParsers.Lazy"><code>CombinedParsers.Lazy</code></a></li><li><a href="lib/public/#CombinedParsers.MatchesIterator"><code>CombinedParsers.MatchesIterator</code></a></li><li><a href="lib/public/#CombinedParsers.NegativeLookahead"><code>CombinedParsers.NegativeLookahead</code></a></li><li><a href="lib/public/#CombinedParsers.NegativeLookbehind"><code>CombinedParsers.NegativeLookbehind</code></a></li><li><a href="lib/public/#CombinedParsers.Never"><code>CombinedParsers.Never</code></a></li><li><a href="lib/public/#CombinedParsers.Optional"><code>CombinedParsers.Optional</code></a></li><li><a href="lib/public/#CombinedParsers.ParseMatch"><code>CombinedParsers.ParseMatch</code></a></li><li><a href="lib/public/#CombinedParsers.PositiveLookahead"><code>CombinedParsers.PositiveLookahead</code></a></li><li><a href="lib/public/#CombinedParsers.PositiveLookbehind"><code>CombinedParsers.PositiveLookbehind</code></a></li><li><a href="lib/public/#CombinedParsers.Repeat"><code>CombinedParsers.Repeat</code></a></li><li><a href="lib/public/#CombinedParsers.Sequence"><code>CombinedParsers.Sequence</code></a></li><li><a href="lib/public/#CombinedParsers.Regexp.integer_base"><code>CombinedParsers.Regexp.integer_base</code></a></li><li><a href="lib/internals/#CombinedParsers._ismatch"><code>CombinedParsers._ismatch</code></a></li><li><a href="lib/internals/#CombinedParsers._iterate"><code>CombinedParsers._iterate</code></a></li><li><a href="lib/internals/#CombinedParsers.deepmap_parser"><code>CombinedParsers.deepmap_parser</code></a></li><li><a href="lib/internals/#CombinedParsers.ismatch"><code>CombinedParsers.ismatch</code></a></li><li><a href="lib/internals/#CombinedParsers.print_constructor"><code>CombinedParsers.print_constructor</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_inner"><code>CombinedParsers.regex_inner</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_prefix"><code>CombinedParsers.regex_prefix</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_string"><code>CombinedParsers.regex_string</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_suffix"><code>CombinedParsers.regex_suffix</code></a></li><li><a href="lib/internals/#CombinedParsers.tuple_pos"><code>CombinedParsers.tuple_pos</code></a></li><li><a href="lib/internals/#CombinedParsers.tuple_state"><code>CombinedParsers.tuple_state</code></a></li><li><a href="lib/internals/#CombinedParsers.CombinedParser"><code>CombinedParsers.CombinedParser</code></a></li><li><a href="lib/internals/#CombinedParsers.ConstantParser"><code>CombinedParsers.ConstantParser</code></a></li><li><a href="lib/internals/#CombinedParsers.FilterParser"><code>CombinedParsers.FilterParser</code></a></li><li><a href="lib/internals/#CombinedParsers.LeafParser"><code>CombinedParsers.LeafParser</code></a></li><li><a href="lib/internals/#CombinedParsers.LookAround"><code>CombinedParsers.LookAround</code></a></li><li><a href="lib/internals/#CombinedParsers.MatchState"><code>CombinedParsers.MatchState</code></a></li><li><a href="lib/internals/#CombinedParsers.MemoTreeChildren"><code>CombinedParsers.MemoTreeChildren</code></a></li><li><a href="lib/internals/#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a></li><li><a href="lib/internals/#CombinedParsers.NIndexParser"><code>CombinedParsers.NIndexParser</code></a></li><li><a href="lib/internals/#CombinedParsers.None"><code>CombinedParsers.None</code></a></li><li><a href="lib/internals/#CombinedParsers.Transformation"><code>CombinedParsers.Transformation</code></a></li><li><a href="lib/internals/#CombinedParsers.WrappedParser"><code>CombinedParsers.WrappedParser</code></a></li><li><a href="lib/internals/#CombinedParsers.Regexp.NoDict"><code>CombinedParsers.Regexp.NoDict</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/guide/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 4 August 2020 17:29">Tuesday 4 August 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
