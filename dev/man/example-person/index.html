<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Names (What is Parsing?) Â· CombinedParsers.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/man/example-person/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CombinedParsers.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../guide/">Overview</a></li><li><a class="tocitem" href="../user/">User Guide</a></li><li><a class="tocitem" href="../example-either-trie/">Prefix-Tree Matching</a></li><li><a class="tocitem" href="../pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Names (What is Parsing?)</a><ul class="internal"><li><a class="tocitem" href="#Reading,-technically,-is-Parsing"><span>Reading, technically, is Parsing</span></a></li><li><a class="tocitem" href="#Adresses"><span>Adresses</span></a></li><li><a class="tocitem" href="#Person&#39;s-adress-data"><span>Person&#39;s adress data</span></a></li></ul></li><li><a class="tocitem" href="../example-number-ranges/">Number sequences (What are Representations?)</a></li><li><a class="tocitem" href="../example-arithmetics/">Arithmetics (Evaluation)</a></li><li><a class="tocitem" href="../pcre/">Regular Expressions</a></li><li><a class="tocitem" href="../json/">JSON (recursion)</a></li><li><a class="tocitem" href="../bson/">BSON (<code>Vector{Unit8}</code> parsing)</a></li><li><a class="tocitem" href="../example-palindromes/">struct Palindrome&lt;:CombinedParser</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/public/">Matching/Parsing</a></li><li><a class="tocitem" href="../../lib/parsers/">Templates</a></li><li><a class="tocitem" href="../../lib/constructors/">Constructors</a></li><li><a class="tocitem" href="../../lib/regexp/">Regexp</a></li><li><a class="tocitem" href="../bnf/">EBNF</a></li><li><a class="tocitem" href="../../lib/transformation/">Transformations</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Names (What is Parsing?)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Names (What is Parsing?)</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Names-and-Adresses"><a class="docs-heading-anchor" href="#Names-and-Adresses">Names and Adresses</a><a id="Names-and-Adresses-1"></a><a class="docs-heading-anchor-permalink" href="#Names-and-Adresses" title="Permalink"></a></h1><p>can be written in different ways, e.g.</p><ol><li>with the name preceding the surname, or</li><li>with the surname preceding a comma and the name.</li></ol><h2 id="Reading,-technically,-is-Parsing"><a class="docs-heading-anchor" href="#Reading,-technically,-is-Parsing">Reading, technically, is Parsing</a><a id="Reading,-technically,-is-Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Reading,-technically,-is-Parsing" title="Permalink"></a></h2><p>When humany read names, we identify different writings with the same name of course. Our smart brains analyzes the series of letter symbols like we move muscles without being aware of every detail, intuitively. Reading texts, we understand what the words mean.</p><p>This post explains how a computer can read (parse) names  with <a href="../../lib/internals/#CombinedParsers.CombinedParser"><code>CombinedParser</code></a> in julia <a href="../../lib/constructors/#CombinedParsers.@syntax"><code>@syntax</code></a>.</p><p>A name can be written in terms of these building blocks,</p><pre><code class="language-julia hljs">using CombinedParsers
import CombinedParsers: word, words
@syntax name = Either(
            Sequence(
                 :lastname =&gt; word,
    		              trim(&quot;,&quot;),  # space-padded comma
        		 :name     =&gt; !words),
            Sequence(!words, whitespace_horizontal, word) do v
                 # anonymous function to reverse NamedTuple order!
                 ( lastname = v[3], name= v[1] )
            end);</code></pre><p>The constructors aim to be read naturally: a <code>name</code> is </p><ul><li><a href="../../lib/constructors/#CombinedParsers.Either"><code>Either</code></a> any of two options, each is a</li><li><a href="../../lib/constructors/#CombinedParsers.Sequence"><code>Sequence</code></a> that picks</li><li>properties <a href="../../lib/constructors/#CombinedParsers.with_name"><code>with_name</code></a> (provided as <code>Pair{Symbol, CombinedParser}</code>s),</li><li>of the<a href="../../lib/transformation/#CombinedParsers.MatchedSubSequence"><code>MatchedSubSequence</code></a> <a href="../../lib/transformation/#Base.:!"><code>(!)</code></a> of <a href="../../lib/parsers/#CombinedParsers.words"><code>CombinedParsers.words</code></a> (or a single <a href="../../lib/parsers/#CombinedParsers.word"><code>CombinedParsers.word</code></a>s), </li><li>seperated by <a href="man/@ref"><code>whitespace_horizontal</code></a> that can be <a href="../../lib/parsers/#CombinedParsers.trim"><code>trim</code></a>med (more flexibly than a lexer),</li><li>and the anonymous function in the second option is transforming a parsing result with <a href="../../lib/transformation/#Base.map"><code>map</code></a>.</li></ul><p>The <code>CombinedParser</code> <code>name</code> is callable to read/parse names:</p><pre><code class="language- hljs">julia&gt; name(&quot;Name Surname&quot;)
(lastname = &quot;Surname&quot;, name = &quot;Name&quot;)</code></pre><p>Using <a href="../../lib/constructors/#CombinedParsers.@syntax"><code>@syntax</code></a> also provides a string macro for parsing:</p><pre><code class="language- hljs">julia&gt; name&quot;Yours, Truely&quot;
(lastname = &quot;Surname&quot;, name = &quot;Name&quot;)</code></pre><h3 id="Julia-NamedTuples-are-a-great-language-feature!"><a class="docs-heading-anchor" href="#Julia-NamedTuples-are-a-great-language-feature!">Julia <code>NamedTuple</code>s are a great language feature!</a><a id="Julia-NamedTuples-are-a-great-language-feature!-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-NamedTuples-are-a-great-language-feature!" title="Permalink"></a></h3><p>The example converts (parses) a matching string to a</p><pre><code class="language- hljs">julia&gt; result_type(name)
(lastname = &quot;Surname&quot;, name = &quot;Name&quot;)</code></pre><p>a type without a dedicated <code>struct</code> name but with field names. (For writing concisely, anonymous <code>struct</code> representations are as useful as anonymous functions. Why?  Omitting to name things works around solving a hard problem.)</p><h2 id="Adresses"><a class="docs-heading-anchor" href="#Adresses">Adresses</a><a id="Adresses-1"></a><a class="docs-heading-anchor-permalink" href="#Adresses" title="Permalink"></a></h2><p>On a letter, the</p><pre><code class="language-julia hljs">@syntax street_adress =
               Sequence(
                   :street =&gt; !words, whitespace_horizontal,
                   :no     =&gt; Numeric(Int));</code></pre><p>Defined parsers can be combined. (And composed with <code>TextParse.</code><a href="man/@ref"><code>Numeric</code></a>, PCRE regular expression and Backus-Naur-Form syntax. Any other parser can be plugged in by writing internal <code>CombinedParser</code> functions.)</p><pre><code class="language-julia hljs">@syntax adress =
                Sequence(
                    Optional(trim(&quot;Adresse:&quot;, whitespace=space_maybe)),
                    :door =&gt; trim(street_adress, whitespace=space_maybe),
                    :zip  =&gt; Numeric(Int),
                    :city =&gt; trim(!words, whitespace=space_maybe))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; adress&quot;&quot;&quot;Allee 47
       80000 Augsburg
       &quot;&quot;&quot;
(door = (street = &quot;Allee&quot;, no = 47), zip = 80000, city = &quot;Augsburg&quot;)</code></pre><h2 id="Person&#39;s-adress-data"><a class="docs-heading-anchor" href="#Person&#39;s-adress-data">Person&#39;s adress data</a><a id="Person&#39;s-adress-data-1"></a><a class="docs-heading-anchor-permalink" href="#Person&#39;s-adress-data" title="Permalink"></a></h2><p>For person entries in texts a <code>CombinedParser</code> can be intuitively written as</p><pre><code class="language-julia hljs">@syntax person_adresses = Sequence(
                    Optional(trim(&quot;Name:&quot;, whitespace=space_maybe)),
                    :person =&gt; name, space_maybe,
                    :adresses =&gt; join(adress, space_maybe));</code></pre><p>Let&#39;s test that parser with a</p><pre><code class="language-julia-repl hljs">julia&gt; function summary(p::result_type(person_adresses)) 
            println(p.person.name, &quot; &quot;, p.person.lastname)
            for a in p.adresses; println(&quot;   &quot;, a.city); end
       end;

julia&gt; person_adresses&quot;&quot;&quot;
       Name: Gottfried Wirklich
       
       Adresse:
       Abhang 19
       86653 Glauberg
       
       Adresse:
       Allee 47
       80650 Pinienstadt
       &quot;&quot;&quot; |&gt; summary
Gottfried Wirklich
   Glauberg
   Pinienstadt</code></pre><p>This example demonstrated <code>CombinedParser.jl</code> for creating <code>NamedTuple</code> representation from <code>String</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pcre-compliance/">Â« PCRE Compliance</a><a class="docs-footer-nextpage" href="../example-number-ranges/">Number sequences (What are Representations?) Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 1 September 2021 11:01">Wednesday 1 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
