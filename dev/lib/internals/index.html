<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · CombinedParsers.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/lib/internals/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CombinedParsers.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/guide/">Overview</a></li><li><a class="tocitem" href="../../man/user/">User Guide</a></li><li><a class="tocitem" href="../../man/example-either-trie/">Prefix-Tree Matching</a></li><li><a class="tocitem" href="../../man/pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../man/example-person/">Names (What is Parsing?)</a></li><li><a class="tocitem" href="../../man/example-number-ranges/">Number sequences (What are Representations?)</a></li><li><a class="tocitem" href="../../man/example-arithmetics/">Arithmetics (Evaluation)</a></li><li><a class="tocitem" href="../../man/pcre/">Regular Expressions</a></li><li><a class="tocitem" href="../../man/json/">JSON (recursion)</a></li><li><a class="tocitem" href="../../man/bson/">BSON (<code>Vector{Unit8}</code> parsing)</a></li><li><a class="tocitem" href="../../man/example-palindromes/">struct Palindrome&lt;:CombinedParser</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Matching/Parsing</a></li><li><a class="tocitem" href="../parsers/">Templates</a></li><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../regexp/">Regexp</a></li><li><a class="tocitem" href="../../man/bnf/">EBNF</a></li><li><a class="tocitem" href="../transformation/">Transformations</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Iterating"><span>Iterating</span></a></li><li class="toplevel"><a class="tocitem" href="#Internal-Types"><span>Internal Types</span></a></li><li><a class="tocitem" href="#Abstract-Parsers"><span>Abstract Parsers</span></a></li><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Wrapped-Parsers"><span>Wrapped Parsers</span></a></li><li><a class="tocitem" href="#Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#Rewriting-Parsers"><span>Rewriting Parsers</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h1><h2 id="Iterating"><a class="docs-heading-anchor" href="#Iterating">Iterating</a><a id="Iterating-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating" title="Permalink"></a></h2><p>Iteration is done with states.</p><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.state_type" href="#CombinedParsers.state_type"><code>CombinedParsers.state_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CombinedParsers.state_type(x::CombinedParser{S}) where S</code></pre><p>Return <code>S</code>, the state type of <code>x</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.MatchesIterator" href="#CombinedParsers.MatchesIterator"><code>CombinedParsers.MatchesIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatchesIterator(parser::P, sequence::S[, start=firstindex(sequence)[, stop=lastindex(sequence), [till=lastindex(sequence)]]])</code></pre><p>Iterator type for <a href="../public/#CombinedParsers.match_all"><code>match_all</code></a> and <a href="../public/#CombinedParsers.parse_all"><code>parse_all</code></a> with <code>eltype</code> <a href="#CombinedParsers.ParseMatch"><code>ParseMatch</code></a><code>{P,S,state_type(P)}</code>.</p><p>Iteration looks for matches beginning between <code>start</code> and <code>stop</code> and ending at most at <code>till</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.ParseMatch" href="#CombinedParsers.ParseMatch"><code>CombinedParsers.ParseMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParseMatch(p::MatchesIterator{P,S}, offset::Integer, after::Integer, state::ST) where {P,S,ST}</code></pre><p>You can extract the following info from a <code>m::ParseMatch</code> object  (like <a href="https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions">Julia RegexMatch</a>, ):</p><ul><li>the entire substring matched: <code>m.match</code></li><li>the offset at which the whole match begins: <code>m.offset</code></li></ul><p>If <code>P&lt;:</code><a href="../regexp/#CombinedParsers.Regexp.ParserWithCaptures"><code>CombinedParsers.Regexp.ParserWithCaptures</code></a> and <code>S&lt;:</code><a href="../regexp/#CombinedParsers.Regexp.SequenceWithCaptures"><code>CombinedParsers.Regexp.SequenceWithCaptures</code></a></p><ul><li>the captured substrings as an array of strings: <code>m.captures</code></li><li>the offsets of the captured substrings as a vector: <code>m.offsets</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.parsematch_tuple" href="#CombinedParsers.parsematch_tuple"><code>CombinedParsers.parsematch_tuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parsematch_tuple(m,offset,state)</code></pre><p>ParseMatch iteration has the first match as iterator, the last match as a state. (Turned out to be fastest.)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers._iterate" href="#CombinedParsers._iterate"><code>CombinedParsers._iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_iterate(parser, sequence, till::Int, posi::Int[, next_i[, state=nothing]])</code></pre><p>Return position <code>after</code> next match of <code>parser</code> in <code>sequence</code> at <code>posi</code>. The next match is following current match <code>state</code> (first match iif <code>state==nothing</code>).</p><p>If no next match is found, return <code>nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>next_i</code> is the index in <code>sequence</code> after <code>parser</code> match at <code>posi</code> with <code>state</code>.</p><ul><li><code>leftof(sequence,next_i,parser,state)==posi</code>, the start of the <code>state</code>-matching subsequence.</li><li><code>rightof(sequence,posi,parser,state)==next_i</code>, the position after the <code>state</code>-matching subsequence.</li><li><code>sequence[leftof(sequence,next_i,parser,state):_prevind(sequence,next_i)]</code> is the matched subsequence.</li></ul></div></div><p>Dispatches to <code>_iterate(parser, sequence,till,posi,posi,nothing)</code> to .</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>custom <code>_iterate</code> implementations <em>must</em> return</p><ul><li><code>nothing</code> if no match is found</li><li><code>Tuple{Int64,state_type(parser)}</code> with next position, match state if a match is found.</li></ul></div></div></div></section><section><div><pre><code class="nohighlight hljs">_iterate(parser::ValueMatcher, sequence, till, posi, next_i, state::Nothing)</code></pre><p>When implementing a <code>Custom&lt;:ValueMatcher</code> it suffices to provide a method <a href="../constructors/#CombinedParsers._ismatch"><code>CombinedParsers._ismatch</code></a><code>(c, parser::Custom)</code>.</p></div></section><section><div><pre><code class="nohighlight hljs">_iterate(p::AbstractTrie{Char}, str, till, posi, next_i, ::Nothing)</code></pre><p>Match char path in <code>p</code> greedily, recording <code>SubTrie</code> in a <a href="#CombinedParsers.NCodeunitsState"><code>NCodeunitsState</code></a>.</p></div></section><section><div><pre><code class="language-julia hljs">_iterate(p::ParserWithCaptures, sequence::SequenceWithCaptures,a...)</code></pre><p><code>Base.empty!(sequence)</code> before iteration. (Why?)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.tuple_pos" href="#CombinedParsers.tuple_pos"><code>CombinedParsers.tuple_pos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tuple_pos(pos_state::Tuple)</code></pre><p><a href="#CombinedParsers._iterate"><code>_iterate</code></a> returns a tuple <code>pos_state</code> or nothing, and  <code>pos_state[1]</code> is position after match.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.tuple_state" href="#CombinedParsers.tuple_state"><code>CombinedParsers.tuple_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tuple_state(pos_state::Tuple)</code></pre><p><a href="#CombinedParsers._iterate"><code>_iterate</code></a> returns a tuple <code>pos_state</code> or nothing, and <code>pos_state[2]</code> is the state of match.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.leftof" href="#CombinedParsers.leftof"><code>CombinedParsers.leftof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leftof(str,i,parser,state)</code></pre><p>Left of <code>parser</code> match in <code>str</code> <em>before</em> <code>i</code> encoded by <code>state</code>, or <code>i</code> if <code>state===nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>override with <a href="#CombinedParsers._leftof"><code>_leftof</code></a> and  <a href="#CombinedParsers._rightof"><code>_rightof</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers._leftof" href="#CombinedParsers._leftof"><code>CombinedParsers._leftof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_leftof(str,i,parser::WrappedParser,x)</code></pre><p>Convienience function for overriding <a href="#CombinedParsers.leftof"><code>leftof</code></a> that guarantees that not <code>x isa Nothing</code> (returning <code>i</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.rightof" href="#CombinedParsers.rightof"><code>CombinedParsers.rightof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rightof(str,i,parser,state)</code></pre><p>Left of <code>parser</code> match in <code>str</code> at <code>i</code> encoded by <code>state</code>, or <code>i</code> if <code>state===nothing</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>override with <a href="#CombinedParsers._leftof"><code>_leftof</code></a> and  <a href="#CombinedParsers._rightof"><code>_rightof</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers._rightof" href="#CombinedParsers._rightof"><code>CombinedParsers._rightof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_rightof(str,i,parser::WrappedParser,x)</code></pre><p>Convienience function for overriding <a href="#CombinedParsers.rightof"><code>rightof</code></a> that guarantees that not <code>x isa Nothing</code> (returning <code>i</code>).</p></div></section></article><p>From result can (re-)construct <a href="#CombinedParsers.leftof"><code>CombinedParsers.leftof</code></a>.</p><h1 id="Internal-Types"><a class="docs-heading-anchor" href="#Internal-Types">Internal Types</a><a id="Internal-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Types" title="Permalink"></a></h1><h2 id="Abstract-Parsers"><a class="docs-heading-anchor" href="#Abstract-Parsers">Abstract Parsers</a><a id="Abstract-Parsers-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Parsers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.CombinedParser" href="#CombinedParsers.CombinedParser"><code>CombinedParsers.CombinedParser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedParser{S,T} &lt;: AbstractToken{T}</code></pre><p>Abstract parser type for parsers returning matches transformed to <code>::T</code> and  state::<code>S</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.LeafParser" href="#CombinedParsers.LeafParser"><code>CombinedParsers.LeafParser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LeafParser{T} &lt;: CombinedParser{T}</code></pre><p>Abstract parser type for parsers that have no sub-parser (e.g. <a href="#CombinedParsers.ConstantParser"><code>ConstantParser</code></a>). Used for dispatch in <a href="#CombinedParsers.deepmap_parser"><code>deepmap_parser</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.Assertion" href="#CombinedParsers.Assertion"><code>CombinedParsers.Assertion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parsers that do not consume any input can inherit <code>Assertion{S,T}</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>TODO: allow to keep state and return wrapped get</p></div></div></div></section></article><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.MatchState" href="#CombinedParsers.MatchState"><code>CombinedParsers.MatchState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State object for a match that is defined by the triple <code>parser, sequence, position</code>.</p><p>!!! note:     Performance tip: <a href="../constructors/#CombinedParsers.Atomic"><code>Atomic</code></a> is masking the state of its wrapped parser with <code>MatchState</code>.     This simplifies the state</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.NoMatch" href="#CombinedParsers.NoMatch"><code>CombinedParsers.NoMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State type for skipped optional. (Missing was breaking julia).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.NCodeunitsState" href="#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State object representing ncodeunits explicitely with state of match for <code>leftof</code>, <code>rightof</code> to improve performance.     <code>nc::Int</code> and <code>state::S</code>.</p><p>See also <a href="#CombinedParsers.MatchState"><code>MatchState</code></a>, <a href="#CombinedParsers.leftof"><code>leftof</code></a>, <a href="#CombinedParsers.rightof"><code>rightof</code></a>.</p><p>!!! note:     <code>nc</code> as type parameter faster but slow compilation.</p></div></section></article><h2 id="Wrapped-Parsers"><a class="docs-heading-anchor" href="#Wrapped-Parsers">Wrapped Parsers</a><a id="Wrapped-Parsers-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapped-Parsers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.FilterParser" href="#CombinedParsers.FilterParser"><code>CombinedParsers.FilterParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A parser succeeds ony if </p><ol><li>the wrapped <code>parser</code> succeeds </li><li>and a predicate function <code>state_filter(sequence, till, posi, r...)</code> returns <code>true</code> the <code>after,state = r</code> tuple.</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.ConstantParser" href="#CombinedParsers.ConstantParser"><code>CombinedParsers.ConstantParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for stepping with ncodeunit length.</p><pre><code class="language-julia-repl hljs">julia&gt; parser(&quot;constant&quot;) isa CombinedParsers.ConstantParser
true

julia&gt; parser(&#39;c&#39;) isa CombinedParsers.ConstantParser
true

julia&gt; parser(1) isa CombinedParsers.ConstantParser
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.NIndexParser" href="#CombinedParsers.NIndexParser"><code>CombinedParsers.NIndexParser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NIndexParser{N,T} &lt;: LeafParser{MatchState,T}</code></pre><p>Abstract type for stepping <code>N</code> indices with <a href="#CombinedParsers._leftof"><code>_leftof</code></a> and <a href="#CombinedParsers._rightof"><code>_rightof</code></a>,  accounting for <code>Base.ncodeunits</code> length of unicode chars.</p><p>See <a href="../constructors/#CombinedParsers.Bytes"><code>Bytes</code></a> and <a href="../constructors/#CombinedParsers.ValueMatcher"><code>ValueMatcher</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.WrappedParser" href="#CombinedParsers.WrappedParser"><code>CombinedParsers.WrappedParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for parser wrappers, providing default methods</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.WrappedAssertion" href="#CombinedParsers.WrappedAssertion"><code>CombinedParsers.WrappedAssertion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An assertion with an inner parser, like WrappedParser interface.</p></div></section></article><h2 id="Printing"><a class="docs-heading-anchor" href="#Printing">Printing</a><a id="Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.print_constructor" href="#CombinedParsers.print_constructor"><code>CombinedParsers.print_constructor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_constructor(io::IO,x)</code></pre><p>Print constructor pipeline in parser tree node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.MemoTreeChildren" href="#CombinedParsers.MemoTreeChildren"><code>CombinedParsers.MemoTreeChildren</code></a> — <span class="docstring-category">Type</span></header><section><div><p>decurse recursive patterns</p></div></section></article><h3 id="PCRE"><a class="docs-heading-anchor" href="#PCRE">PCRE</a><a id="PCRE-1"></a><a class="docs-heading-anchor-permalink" href="#PCRE" title="Permalink"></a></h3><p>printing currently in tree view, but has inconsistencies (might not result in the PCRE regex equivalent to the parser).</p><article class="docstring"><header><a class="docstring-binding" id="Base.escape_string" href="#Base.escape_string"><code>Base.escape_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.escape_string(x::AbstractVector)</code></pre><p>for printing a non-string sequence when parsing.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>type piracy? module local <code>_escape_string</code>?</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_string" href="#CombinedParsers.regex_string"><code>CombinedParsers.regex_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regex_string(x::CombinedParser)</code></pre><p><code>regex_prefix(x)*regex_inner(x)*regex_suffix(x)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_prefix" href="#CombinedParsers.regex_prefix"><code>CombinedParsers.regex_prefix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regex_prefix(x)</code></pre><p>Prefix printed in parser tree node.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_inner" href="#CombinedParsers.regex_inner"><code>CombinedParsers.regex_inner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regex_inner(x::AbstractToken)</code></pre><p>Regex representation of <code>x</code>. See <a href="#CombinedParsers.regex_string"><code>regex_string</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_suffix" href="#CombinedParsers.regex_suffix"><code>CombinedParsers.regex_suffix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">regex_suffix(x)</code></pre><p>Suffix printed in parser tree node.</p></div></section></article><h2 id="Rewriting-Parsers"><a class="docs-heading-anchor" href="#Rewriting-Parsers">Rewriting Parsers</a><a id="Rewriting-Parsers-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-Parsers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.deepmap_parser" href="#CombinedParsers.deepmap_parser"><code>CombinedParsers.deepmap_parser</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deepmap_parser(f::Function[, mem::AbstractDict=IdDict()], x::CombinedParser,a...;kw...)</code></pre><p>Perform a deep transformation of a <code>x</code>.</p><p>Default method</p><ol><li>Returns cached result if <code>haskey(x, mem)</code> to avoid infinite recursion.</li><li>construct deep transformation <code>dt = _deepmap_parser(f, mem, x, a...; kw...)</code></li><li>cache and return <code>f(dt, a...; kw...)</code></li></ol><p>Used for <a href="../constructors/#CombinedParsers.log_names"><code>log_names</code></a>.</p><p><strong>For a new <code>CombinedParser</code>,</strong></p><p>define either <code>deepmap_parser</code> or <code>_deepmap_parser</code>.</p><p><strong>For a parser transformation <code>f</code>,</strong></p><p>define either custom</p><ul><li><code>deepmap_parser(::typeof(f),...)</code> (see example implementation <a href="../constructors/#CombinedParsers.substitute"><code>substitute</code></a>)</li><li>construction method <code>_deepmap_parser(::typeof(f),...)</code>  (see example implementation <a href="../parsers/#CombinedParsers.caseless"><code>caseless</code></a>)</li><li>leaf method <code>f</code> (see example implementation <a href="../transformation/#CombinedParsers.deepmap"><code>deepmap</code></a>)</li></ul></div></section><section><div><pre><code class="nohighlight hljs">_deepmap_parser(::typeof(_indexed_captures),mem::AbstractDict,x::Either,context,reset_index)</code></pre><p>Method dispatch, resetting <code>lastindex(context.subroutines)</code> if `reset_index===true&#39;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers._deepmap_parser" href="#CombinedParsers._deepmap_parser"><code>CombinedParsers._deepmap_parser</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deepmap_parser(f,mem::AbstractDict,x,a...;kw...)</code></pre><p>Perform a deep transformation of a CombinedParser.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For a custom parser <code>P&lt;:CombinedParser</code> with sub-parsers, provide a method</p><pre><code class="language-julia hljs">CombinedParsers._deepmap_parser(f,mem::AbstractDict,x::P,a...;kw...) =
     ## construct replacement, e.g. if P &lt;: WrappedParser
     P(deepmap_parser(f,mem,x.parser,a...;kw...))</code></pre></div></div></div></section><section><div><pre><code class="nohighlight hljs">_deepmap_parser(f::typeof(_indexed_captures),mem::AbstractDict,x::DupSubpatternNumbers,context,reset_index)</code></pre><p>set `reset_index===true&#39;.</p></div></section><section><div><pre><code class="nohighlight hljs">_deepmap_parser(f::typeof(_indexed_captures),mem::AbstractDict,x::Capture,context,a...)</code></pre><p>Map the capture my setting <code>index</code> to  <code>_nextind(context,x)</code>.</p><p>Registers result in <code>context.subroutines</code> if no previous subroutine with the same index exists (see also <a href="../regexp/#CombinedParsers.Regexp.DupSubpatternNumbers"><code>DupSubpatternNumbers</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.reinfer" href="#CombinedParsers.reinfer"><code>CombinedParsers.reinfer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reinfer(parser)</code></pre><p>Run julia type inference again on a parser for optimization. <a href="../constructors/#CombinedParsers.Either"><code>Either</code></a><code>{&lt;:Vector}</code> parsers are converted to <code>Either{&lt;:Tuple}</code>.</p><p>Implementation is an example when the a custom <a href="#CombinedParsers.deepmap_parser"><code>deepmap_parser</code></a> method is useful.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.strip_either1" href="#CombinedParsers.strip_either1"><code>CombinedParsers.strip_either1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">strip_either1(x::CombinedParser)</code></pre><p>Replace all <code>Either</code> parsers with one option with that option.</p><p>Used in 2-stage <a href="../constructors/#CombinedParsers.substitute"><code>substitute</code></a> (stage 1: collect for recursion, stage 2: simplify).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.Regexp.NoDict" href="#CombinedParsers.Regexp.NoDict"><code>CombinedParsers.Regexp.NoDict</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For use in ParserWithCaptures to enforce different indices for identical captures.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transformation/">« Transformations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 1 September 2021 11:01">Wednesday 1 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
