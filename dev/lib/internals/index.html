<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · CombinedParsers.jl</title><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/lib/internals/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CombinedParsers.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/guide/">Overview</a></li><li><a class="tocitem" href="../../man/user/">User Guide</a></li><li><a class="tocitem" href="../../man/example-either-trie/">Prefix-Tree Matching</a></li><li><a class="tocitem" href="../../man/pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../man/example-person/">What is Parsing? Names...</a></li><li><a class="tocitem" href="../../man/example-number-ranges/">Representations: Number sequences</a></li><li><a class="tocitem" href="../../man/pcre/">Regular Expressions</a></li><li><a class="tocitem" href="../../man/example-palindromes/">struct Palindrome&lt;:CombinedParser</a></li><li><a class="tocitem" href="../../man/example-arithmetics/">Arithmetics</a></li><li><a class="tocitem" href="../../man/bson/">Parsing <code>Vector{Unit8}</code>: BSON</a></li><li><a class="tocitem" href="../../man/json/">JSON</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public</a></li><li><a class="tocitem" href="../regexp/">Regexp</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Iterating-Parsings"><span>Iterating Parsings</span></a></li><li class="toplevel"><a class="tocitem" href="#Internal-Types"><span>Internal Types</span></a></li><li><a class="tocitem" href="#Abstract-Parsers"><span>Abstract Parsers</span></a></li><li><a class="tocitem" href="#Wrapped-Parsers"><span>Wrapped Parsers</span></a></li><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#Rewriting-Parsers"><span>Rewriting Parsers</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gkappler/CombinedParsers.jl/blob/master/docs/src/lib/internals.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal-API"><a class="docs-heading-anchor" href="#Internal-API">Internal API</a><a id="Internal-API-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-API" title="Permalink"></a></h1><h2 id="Iterating-Parsings"><a class="docs-heading-anchor" href="#Iterating-Parsings">Iterating Parsings</a><a id="Iterating-Parsings-1"></a><a class="docs-heading-anchor-permalink" href="#Iterating-Parsings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.MatchesIterator" href="#CombinedParsers.MatchesIterator"><code>CombinedParsers.MatchesIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Iterator type for <code>match_all</code> and <code>parse_all</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/base/#L0-L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.parsematch_tuple" href="#CombinedParsers.parsematch_tuple"><code>CombinedParsers.parsematch_tuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parsematch_tuple(m,start,state)</code></pre><p>ParseMatch iteration has the first match as iterator, the last match as a state. (Turned out to be fastest.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/match.jl#LL103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prevind" href="#Base.prevind"><code>Base.prevind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.prevind(str,i::Int,parser,state)</code></pre><p>Return the index before the <code>state</code> match ending before position <code>i</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>I am in doubt whether this qualifies as type piracy because I provide an outside method for outside types. I thought it might not, because the differentiating two extra arguments. If you have an opinion, please let me know on GitHub.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL171-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.nextind" href="#Base.nextind"><code>Base.nextind</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Base.nextind(str,i::Int,parser,state)</code></pre><p>Return the index after the <code>state</code> match at <code>i</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>I am in doubt whether this qualifies as type piracy because I provide an outside method for outside types. I thought it might not, because the differentiating two extra arguments. If you have an opinion, please let me know on GitHub.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.ismatch" href="#CombinedParsers.ismatch"><code>CombinedParsers.ismatch</code></a> — <span class="docstring-category">Function</span></header><section><div><p>&quot;     ismatch(c::Char,p::Union{Function,Steprange,Set,UnicodeClass})::Bool</p><p>checks is a character matches a pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL527-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers._ismatch" href="#CombinedParsers._ismatch"><code>CombinedParsers._ismatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_ismatch(x::Char, set::Union{Tuple,Vector})::Bool</code></pre><p><code>_ismatch(x,set...)</code> respects boolean logic:</p><p>Example:</p><pre><code class="language-julia-repl">julia&gt; p = CharNotIn(CharNotIn(&quot;ab&quot;));

julia&gt; parse(p,&quot;a&quot;)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL539-L552">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers._iterate" href="#CombinedParsers._iterate"><code>CombinedParsers._iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">_iterate(p::ParserWithCaptures, sequence::SequenceWithCaptures,a...)</code></pre><p><code>Base.empty!(sequence)</code> before iteration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/indexed_captures.jl#LL23-L27">source</a></section><section><div><pre><code class="language-none">_iterate(parser, sequence, till::Int, posi::Int[, nothing])</code></pre><p>Dispatches to <code>_iterate(parser, sequence,till,posi,posi,nothing)</code> to retrieve first match, or nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL97-L101">source</a></section><section><div><pre><code class="language-none">_iterate(parser, sequence, till, posi, next_i, states)</code></pre><p>Note: <code>next_i</code> is the index in <code>sequence</code> after <code>parser</code> match according to <code>state</code> (and not the start of the match),  such that <code>start_index(sequence,after,parser,state)</code> returns the start of the matching subsequence, and sequence[start<em>index(sequence,after,parser,state):prevind(sequence,next</em>i)] is the matched subsequence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL128-L134">source</a></section><section><div><pre><code class="language-none">_iterate(p::Trie{Char}, str, till, posi, next_i, ::Nothing)</code></pre><p>Match char path in <code>p</code> greedily, recording shorter matches in state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/trie.jl#LL21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.tuple_pos" href="#CombinedParsers.tuple_pos"><code>CombinedParsers.tuple_pos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tuple_pos(pos_state::Tuple)</code></pre><p><code>pos_state[1]</code> is position after match in tuple returned by <a href="#CombinedParsers._iterate"><code>_iterate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.tuple_state" href="#CombinedParsers.tuple_state"><code>CombinedParsers.tuple_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tuple_state(pos_state::Tuple)</code></pre><p><code>pos_state[2]</code> is state of match in tuple returned by <a href="#CombinedParsers._iterate"><code>_iterate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL119-L123">source</a></section></article><h1 id="Internal-Types"><a class="docs-heading-anchor" href="#Internal-Types">Internal Types</a><a id="Internal-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Types" title="Permalink"></a></h1><h2 id="Abstract-Parsers"><a class="docs-heading-anchor" href="#Abstract-Parsers">Abstract Parsers</a><a id="Abstract-Parsers-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Parsers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.ParserTypes" href="#CombinedParsers.ParserTypes"><code>CombinedParsers.ParserTypes</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Julia types that provide CombinedParser methods result<em>type, state</em>type, _iterate, get, nextind, prevind.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.CombinedParser" href="#CombinedParsers.CombinedParser"><code>CombinedParsers.CombinedParser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CombinedParser{T,S} &lt;: AbstractToken{T}</code></pre><p>Abstract parser type for parsers returning matches transformed to <code>::T</code> and  state::<code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.LeafParser" href="#CombinedParsers.LeafParser"><code>CombinedParsers.LeafParser</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LeafParser{T} &lt;: AbstractToken{T}</code></pre><p>Abstract parser type for parsers that have no sub-parser. Used for dispatch in <a href="#CombinedParsers.deepmap_parser"><code>deepmap_parser</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL244-L249">source</a></section></article><h2 id="Wrapped-Parsers"><a class="docs-heading-anchor" href="#Wrapped-Parsers">Wrapped Parsers</a><a id="Wrapped-Parsers-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapped-Parsers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.FilterParser" href="#CombinedParsers.FilterParser"><code>CombinedParsers.FilterParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A parser succeeds ony if </p><ol><li>the wrapped <code>parser</code> succeeds </li><li>and a predicate function <code>state_filter(sequence, till, posi, r...)</code> returns <code>true</code> the <code>after,state = r</code> tuple.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.ConstantParser" href="#CombinedParsers.ConstantParser"><code>CombinedParsers.ConstantParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for stepping with ncodeunit length.</p><pre><code class="language-julia-repl">julia&gt; parser(&quot;constant&quot;) isa CombinedParsers.ConstantParser
true

julia&gt; parser(&#39;c&#39;) isa CombinedParsers.ConstantParser
true

julia&gt; parser(1) isa CombinedParsers.ConstantParser
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/base/#L0-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.NIndexParser" href="#CombinedParsers.NIndexParser"><code>CombinedParsers.NIndexParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for stepping with previndex/nextindex, accounting for ncodeunit length of chars at point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.WrappedParser" href="#CombinedParsers.WrappedParser"><code>CombinedParsers.WrappedParser</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for parser wrappers, providing default methods</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.Transformation" href="#CombinedParsers.Transformation"><code>CombinedParsers.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transformation{T}(f::Function, p_) where {T}
Base.map(f::Function, Tc::Type, p::ParserTypes, a...)
Base.map(f::Function, p::ParserTypes, a...)</code></pre><p>Parser transforming result of a wrapped parser.  <code>a...</code> is passed as additional arguments to <code>f</code> (at front .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.LookAround" href="#CombinedParsers.LookAround"><code>CombinedParsers.LookAround</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parsers that do not consume any input can inherit this type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL672-L674">source</a></section></article><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.MatchState" href="#CombinedParsers.MatchState"><code>CombinedParsers.MatchState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State object for a match that is defined by the parser, sequence and position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.None" href="#CombinedParsers.None"><code>CombinedParsers.None</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State type for skipped optional. (Missing was breaking julia).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL2283-L2285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.NCodeunitsState" href="#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>State object representing ncodeunits explicitely with state of match for <code>prevind</code>, <code>nextind</code> to improve performance.     nc::Int     state::S</p><p>See also <a href="#CombinedParsers.MatchState"><code>MatchState</code></a>, <a href="#Base.prevind"><code>prevind</code></a>, <a href="#Base.nextind"><code>nextind</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL195-L201">source</a></section></article><h2 id="Printing"><a class="docs-heading-anchor" href="#Printing">Printing</a><a id="Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_string" href="#CombinedParsers.regex_string"><code>CombinedParsers.regex_string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">regex_string(x::CombinedParser)</code></pre><p><code>regex_prefix(x)*regex_inner(x)*regex_suffix(x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL310-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_prefix" href="#CombinedParsers.regex_prefix"><code>CombinedParsers.regex_prefix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">regex_prefix(x)</code></pre><p>Prefix printed in parser tree node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL317-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_inner" href="#CombinedParsers.regex_inner"><code>CombinedParsers.regex_inner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">regex_inner(x::AbstractToken)</code></pre><p>Regex representation of <code>x</code>. See <a href="#CombinedParsers.regex_string"><code>regex_string</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL329-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.regex_suffix" href="#CombinedParsers.regex_suffix"><code>CombinedParsers.regex_suffix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">regex_suffix(x)</code></pre><p>Suffix printed in parser tree node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.print_constructor" href="#CombinedParsers.print_constructor"><code>CombinedParsers.print_constructor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">print_constructor(io::IO,x)</code></pre><p>Print constructor pipeline in parser tree node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL345-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.MemoTreeChildren" href="#CombinedParsers.MemoTreeChildren"><code>CombinedParsers.MemoTreeChildren</code></a> — <span class="docstring-category">Type</span></header><section><div><p>decurse recursive patterns</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/show.jl#LL3-L5">source</a></section></article><h2 id="Rewriting-Parsers"><a class="docs-heading-anchor" href="#Rewriting-Parsers">Rewriting Parsers</a><a id="Rewriting-Parsers-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriting-Parsers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.deepmap_parser" href="#CombinedParsers.deepmap_parser"><code>CombinedParsers.deepmap_parser</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deepmap_parser(f::typeof(indexed_captures_),mem::AbstractDict,x::DupSubpatternNumbers,context,reset_index)</code></pre><p>set `reset_index===true&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/indexed_captures.jl#LL130-L134">source</a></section><section><div><pre><code class="language-none">deepmap_parser(::typeof(indexed_captures_),mem::AbstractDict,x::Either,context,reset_index)</code></pre><p>Method dispatch, resetting <code>lastindex(context.subroutines)</code> if `reset_index===true&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/indexed_captures.jl#LL144-L148">source</a></section><section><div><pre><code class="language-none">deepmap_parser(f::typeof(indexed_captures_),mem::AbstractDict,x::Capture,context,a...)</code></pre><p>Map the capture my setting <code>index</code> to  <code>nextind(context,x)</code>.</p><p>Registers result in <code>context.subroutines</code> if no previous subroutine with the same index exists (see also <a href="../regexp/#CombinedParsers.Regexp.DupSubpatternNumbers"><code>DupSubpatternNumbers</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/indexed_captures.jl#LL173-L180">source</a></section><section><div><pre><code class="language-none">deepmap_parser(f::Function,x::CombinedParser,a...;kw...)</code></pre><p>Perform a deep transformation of a CombinedParser. Used for <a href="../public/#CombinedParsers.log_names"><code>log_names</code></a>.</p><p>Calls <code>deepmap_parser(f,IdDict(),x,a...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL255-L262">source</a></section><section><div><pre><code class="language-none">deepmap_parser(f::Function,mem::AbstractDict,x,a...;kw...)</code></pre><p>Perform a deep transformation of a CombinedParser.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For a custom parser <code>P&lt;:CombinedParser</code> with sub-parsers, provide a method</p><pre><code class="language-julia">deepmap_parser(f::Function,mem::AbstractDict,x::P,a...;kw...) =
    get!(mem,x) do
        ## construct replacement, e.g. if P &lt;: WrappedParser
        P(deepmap_parser(f,mem,x.parser,a...;kw...))
    end</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL266-L280">source</a></section><section><div><pre><code class="language-none">deepmap_parser(f::Function,mem::AbstractDict,x::LeafParser,a...;kw...)</code></pre><p>return </p><pre><code class="language-julia">    get!(mem,x) do
        f(x,a...;kw...)
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/CombinedParsers.jl#LL293-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers.Regexp.NoDict" href="#CombinedParsers.Regexp.NoDict"><code>CombinedParsers.Regexp.NoDict</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For use in ParserWithCaptures to enforce different indices for identical captures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/93c9b71cfae3be54162eac4e3975771364b77d0f/src/indexed_captures.jl#LL196">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../regexp/">« Regexp</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 19 August 2020 11:51">Wednesday 19 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
