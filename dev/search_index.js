var documenterSearchIndex = {"docs":
[{"location":"user/#Basics-1","page":"User Guide","title":"Basics","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The simplest parser matches a String or Char iterator.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse_a = parser(\"aa\")\n\nparse(parse_a,\"aa\")\n# \"aa\"\n\nparse(parse_a,\"ab\")\n# ArgumentError: expected re\"a\" in \"ab\" at index 2 (todo!)","category":"page"},{"location":"user/#Character-Sets-1","page":"User Guide","title":"Character Sets","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(CharIn('a':'z'),\"c\") =='c'\nparse(CharIn(isuppercase),\"A\") =='A'\nparse(CharNotIn('a':'z'),\"A\") =='A'\nparse(CharNotIn(isuppercase),\"c\") =='c'","category":"page"},{"location":"user/#Sequence-1","page":"User Guide","title":"Sequence","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Several parsers can be combined with the Sequence constructor and the * operator. The result_type of a Sequence is the Tuple of the result_types of its parts.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(Sequence(CharIn(isuppercase) * CharIn(islowercase)),\"Ab\") == ('A','b')\nparse(CharIn(isuppercase) * CharIn(islowercase),\"Ab\") == ('A','b')","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"getindex on a sequence creates a transforming parser selecting from the result of the parsing.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Sequence keyword argument constructors transform the parsing into a named tuple.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(Sequence(first = CharIn(isuppercase), second = CharIn(islowercase)),\"Ab\") == \n\t(first='A',second='b')","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"If some Sequence arguments are <:Pair{Symbol}, only those are retained in a NamedTuple.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(Sequence(CharIn(isuppercase), :second => CharIn(islowercase)),\"Ab\") == \n\t(second='b',)","category":"page"},{"location":"user/#Either-1","page":"User Guide","title":"Either","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The | operator and constructor Either try matching the provided parsers in order, accepting the first match, and fails if all parsers fail.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse((\"a\"|\"ab\"),\"ab\")\n# \"a\"","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Feedback inquiry:","category":"page"},{"location":"user/#Assertions-1","page":"User Guide","title":"Assertions","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Parsers that do not advance the parsing position can be used to assert conditions during parsing.","category":"page"},{"location":"user/#AtStart()-and-AtEnd()-1","page":"User Guide","title":"AtStart() and AtEnd()","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The AtStart() only succeeds if at the start of the input, and similarly the AtEnd() succeeds only at the end of the input. By default, parse does not need to consume the full input but succeeds with the first match. With AtEnd() the parser can be forced to consume the full input or fail otherwise.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse((\"a\"|\"ab\")*AtEnd(),\"ab\")\n# \"ab\"","category":"page"},{"location":"user/#Looking-around-1","page":"User Guide","title":"Looking around","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"A Lookaround parser wraps a parser p, succeeds if p matches without advancing the position, and fails if p fails.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The @re_str macro has a regex parser for lookahead and lookbehind expressions (simplified):","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"@with_names lookahead=Sequence(\n    2,\n    \"(?\",\n    Either(Sequence(v->PositiveLookahead(v[2]), \"=\", alternation),\n           Sequence(v->NegativeLookahead(v[2]), \"!\", alternation)),\n           Sequence(v->PositiveLookbehind(v[2]), \"<=\", alternation)),\n           Sequence(v->NegativeLookbehind(v[2]), \"<!\", alternation)),\n    \")\");","category":"page"},{"location":"user/#Repeat-1","page":"User Guide","title":"Repeat","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The Repeat(p) constructor creates a new parser repeating its argument zero or more times, and by default transforming to Vector{result_type(p)}. Repeating a specified number of times can be achieved with Repeat(p,min=1,max=2), or Repeat(1,p) or Repeat(1,2,p). Equivalently the ^ operator can be used similar as for String, e.g. p^2,  and like in regular expressions p^(+), p^(*).","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(join(parser('a')^(*),\" \"),\"a a\") == \n\t['a','a']","category":"page"},{"location":"user/#Optional-1","page":"User Guide","title":"Optional","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Similar to Repeat, Optional(p) creates a parser, repeating 0 or 1 times.  The result_type(Optional(p, default=d)) is promote_type (or Union type is type promotion results in Any).","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"option = Optional('a') * join(Repeat('b'),\"-\")","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Feedback appreciated:","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"option = ( CharIn('a':'z') | missing ) * join(Repeat('b'),\"-\")","category":"page"},{"location":"user/#Lazy-repetitions-and-optional-parsers-1","page":"User Guide","title":"Lazy repetitions and optional parsers","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Repetition and optional parsers are greedy by default, and can be switched to lazy matching by wrapping in Lazy(Repeat(p)).","category":"page"},{"location":"user/#Atomic-groups-1","page":"User Guide","title":"Atomic groups","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Backtracking of a parser p can be prevented by wrapping in Atomic(Repeat(p)). An atomic parser fails if p fails or if the first successfull parsing with p leads to a failing later in the parsing process.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(Either(\"a\",\"ab\",\"ac\")*AtEnd(),\"ab\") == (\"ab\", AtEnd())\nparse(Atomic(Either(\"a\",\"ab\",\"ac\"))*AtEnd(),\"ab\") # fails","category":"page"},{"location":"user/#Acknowledgements-1","page":"User Guide","title":"Acknowledgements","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The work was inspired by Scala FastParse package and the Julia parsing packages","category":"page"},{"location":"user/#Parsers.jl-1","page":"User Guide","title":"Parsers.jl","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"For date and primitive types.","category":"page"},{"location":"user/#TextParse-1","page":"User Guide","title":"TextParse","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"used in CSV.jl\nuses Nullables\nCombinedParsers.AbstractParser <: TextParse.AbstractToken","category":"page"},{"location":"user/#Automa.jl-1","page":"User Guide","title":"Automa.jl","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"grammar based state machine compiler\nno UTF8 support","category":"page"},{"location":"user/#ParserCombinator.jl-1","page":"User Guide","title":"ParserCombinator.jl","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"old source base (pre 2016, fixed for Julia 1.0 in 2018)\nusing Nullables\nno iterator API\nperformance \nmutable matcher types\nmatcher types not parametric","category":"page"},{"location":"user/#Regular-expressions:-Either,-Characters,-and-logging-1","page":"User Guide","title":"Regular expressions: Either, Characters, and logging","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Lets build the major scaffold of the parser for regular expressions from scratch now!","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"import CombinedParsers.Regexp: meta_chars\n\nchar_matcher =  Either(\n    \n    with_name(\"character\", \n        CharNotIn([ c for c in meta_chars])),\n    \n    with_name(\"escaped meta\", \n        Sequence(2, # emit unescaped\n            '\\\\', CharIn(meta_chars)))\n    \n)","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"@show pcre = Regex(regex_string(char))\n\n@show match(pcre,\"a\")\n@show match(pcre,\"\\\\[\")\n\n@show match(log_names(char),\"a\")\n@show match(char,\"\\\\[\"; log=true)","category":"page"},{"location":"user/#Transforming-a-Parsing-1","page":"User Guide","title":"Transforming a Parsing","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The Julia map method for CombinedParsers.AbstractParser creates a transforming parser. The parser for escaped and not escaped regular expression characters char can be transformed to emit not the Char but an CharIn<:AbstractParser matching the unescaped character.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"@show result_type(char_matcher)\n\n@show parsed_obracket = parse(char_matcher,\"\\\\[\")","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"result_type(char_matcher) = Char\nparsed_obracket = parse(char_matcher, \"\\\\[\") = '['\n\n\n\n\n\n'[': ASCII/Unicode U+005b (category Ps: Punctuation, open)","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"char_parser_parser = map(CharIn,char_matcher)\n@show result_type(char_parser_parser)\n\n@show parsed_obracket_parser = parse(char_parser_parser,\"\\\\[\")\n\nparse(parsed_obracket_parser,\"[\")","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"result_type(char_parser_parser) = CharIn\nparsed_obracket_parser = parse(char_parser_parser, \"\\\\[\") = re\"\\[\"\n\n\n\n\n\n'[': ASCII/Unicode U+005b (category Ps: Punctuation, open)","category":"page"},{"location":"user/#Repeat,-Transformation,-and-Sequence-1","page":"User Guide","title":"Repeat, Transformation, and Sequence","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"A basic feature of regular expression is whether a repeatable pattern (e.g. a char) is optional ?, or should be repeated at least once +, any times *, or {min,max} times.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The CombinedParser to parse the (min, max) tuple from PCRE syntax:","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"import CombinedParsers.Regexp: integer\n\n# https://www.pcre.org/original/doc/html/pcrepattern.html#SEC17\n@with_names repetition = Either(\n    \"?\" => (0,1), #  `Pair` syntax to map a match to a constant\n    \n    \"+\" => (1,typemax(Int)),\n    \"*\" => (0,typemax(Int)),\n    Sequence(\n        \"{\", \n        \n        integer,\n        Optional( Sequence(2,\",\",\n            Optional(integer, default=typemax(Int)))),\n        \n        \"}\") do v  # the do syntax implicitly calling map on the sequence\n            if v[3] isa Missing\n                (v[2],v[2])\n            else\n                (v[2],v[3])\n            end::Tuple{Int,Int}\n    end\n)\n\n@show result_type(repetition)\n@show parse(repetition, \"?\")\n@show parse(repetition, \"{1}\");","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"result_type(repetition) = Tuple{Int64,Int64}\nparse(repetition, \"?\") = (0, 1)\nparse(repetition, \"{1}\") = (1, 1)","category":"page"},{"location":"user/#Repeatable-patterns,-Optional,-Lazy-and-Atomic-1","page":"User Guide","title":"Repeatable patterns, Optional, Lazy and Atomic","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The character matcher is the simplest repeatable pattern.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"The CombinedParser to parse a repeated matcher from PCRE syntax","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"repeatable = Either{AbstractParser}(\n    Any[char_parser_parser])\n# we will add groups to repeatable later\n\n@with_names quantified=Sequence(\n        repeatable,\n        Optional(repetition, default=(1,1)),\n        Optional(map(v->convert(Char,v),CharIn('+','?'))) # possessive quantifier\n    ) do v\n        pat = v[1]\n        result = if v[2]==(1,1)\n            pat\n        elseif v[2]==(0,1)\n            Optional(pat)\n        else\n            Repeat(pat,v[2])\n        end\n        if v[3] === missing\n            result\n        elseif v[3]=='+'\n            Atomic(result)\n        elseif v[3]=='?'\n            Lazy(result)\n        else\n            result\n        end\n    end\n\n\nparse(log_names(quantified), raw\"\\++?\")","category":"page"},{"location":"user/#Sequences-and-Alternations-1","page":"User Guide","title":"Sequences and Alternations","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Regular expression patterns can be written in sequence, delimited by | for matching either one of several alternatives.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"@with_names begin\n    sequence = map( v->sSequence(v...),\n        Repeat( quantified ))\n\n    alternation = Sequence(\n        sequence, \n        Repeat(Sequence(2, '|',sequence))) do v\n            sEither(v[1],v[2]...)::AbstractParser\n        end\nend;\n","category":"page"},{"location":"user/#Captures-1","page":"User Guide","title":"Captures","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"Parentheses allow groupings that are repeatable.","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"import CombinedParsers.Regexp: name\n\n@with_names begin\n    noncapture_group=Sequence( 2, \"(?:\",alternation,\")\")\n\n    capture_group=Sequence(\"(\",alternation,\")\") do v\n                Capture(v[2])\n    end;\nend\npush!(repeatable,capture_group);\npush!(repeatable,noncapture_group);","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"alternation\n# is a parser","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"# the alternation parser transforms a regex string into a parser\n\n@show result_type(alternation)\n\nab_parser = parse(log_names(alternation),\"(?:a|b)+\")","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"# the ab_parser\nmatch(ab_parser,\"aab\")\n","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"ParseMatch(\"aab\")","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"# We quickly wrote a parser for regular expressions that generates a PCRE equivalent CombinedParser.\n\n@show parse(parse(alternation,raw\"reg(ular )?ex(p(ression)?)?\\??\"), \"regex\")\nparse(re\"reg(ular )?ex(p(ression)?)?\\??\", \"regex\")","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"parse(parse(alternation, #= In[32]:3 =# @raw_str(\"reg(ular )?ex(p(ression)?)?\\\\??\")), \"regex\") = ('r', 'e', 'g', missing, 'e', 'x', missing, missing)\n\n\n\n\n\n('r', 'e', 'g', missing, 'e', 'x', missing, missing)","category":"page"},{"location":"user/#Looking-around-2","page":"User Guide","title":"Looking around","text":"","category":"section"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"\n@with_names lookahead=Sequence(\n    2,\n    \"(\",\n    Either(Sequence(\n            v -> look_ahead(true,v[2]),\n            Either(\"?=\",\"*positive_lookahead:\",\"*pla:\"),\n            alternation),\n        Sequence(\n            v -> look_ahead(false,v[2]),\n            Either(\"?!\",\"*negative_lookahead:\",\"*nla:\"),\n            alternation)),\n    \")\");\npush_first!(repeatable,lookahead);\n\n\n\n@with_names lookbehind=Sequence(\n    2,\n    \"(\",\n    Either(Sequence(v -> look_behind(true,v[2]),\n            Either(\"?<=\",\"*positive_lookbehind:\",\"*plb:\"),alternation),\n        Sequence(v -> look_behind(false,v[2]),\n            Either(\"?<!\",\"*negative_lookbehind:\",\"*nlb:\"),alternation)),\n    \")\");\npush_first!(repeatable,lookbehind);\n\n","category":"page"},{"location":"user/#","page":"User Guide","title":"User Guide","text":"import CombinedParsers.Regexp: bracket\npush!(repeatable,bracket);\nbracket","category":"page"},{"location":"lib/public/#Public-Documentation-1","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"Documentation for CombinedParsers.jl's public interface.","category":"page"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"lib/public/#Public-Interface-1","page":"Public Documentation","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/#CombinedParsers-1","page":"Public Documentation","title":"CombinedParsers","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"CombinedParsers","category":"page"},{"location":"lib/public/#CombinedParsers","page":"Public Documentation","title":"CombinedParsers","text":"A package for combining parsers and transforming strings into julia types.\n\nCompose parsers with the functional parser combinator paradigm, utilize Julia's type inferrence for transformations, log conveniently for debugging, and let Julia compile your parser for good performance.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CombinedParsers.Regexp-1","page":"Public Documentation","title":"CombinedParsers.Regexp","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"CombinedParsers.Regexp\nCombinedParsers.Regexp.@re_str\nCombinedParsers.Regexp.match\nregex_escape","category":"page"},{"location":"lib/public/#CombinedParsers.Regexp","page":"Public Documentation","title":"CombinedParsers.Regexp","text":"A regular expression parser transforming a PCRE string to a CombinedParser equivalent to the regular expression.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CombinedParsers.Regexp.@re_str","page":"Public Documentation","title":"CombinedParsers.Regexp.@re_str","text":"@re_str(x,flags)\n\nPlug-in replacement for PCRE string macro @r_str. Constructs a CombinedParser equivalent to the PCRE regular expression. Supported flags are parsed \n\nxx Base.PCRE.EXTENDED_MORE\ni Base.PCRE.CASELESS\nm Base.PCRE.MULTILINE\nn Base.PCRE.NOAUTOCAPTURE\nU Base.PCRE.UNGREEDY\nJ Base.PCRE.DUPNAMES\ns Base.PCRE.DOTALL\nx Base.PCRE.EXTENDED\n\nUnsupported\n\ng UInt32(0),\nB UInt32(0)\n\njulia> re\"a|b|c\"i\n|ðŸ—„... Either |> regular expression combinator\nâ”œâ”€ [aA]\nâ”œâ”€ [bB]\nâ””â”€ [cC]\n::Char\n\njulia> re\"(a|b)+c\"\nðŸ—„ Sequence |> regular expression combinator with 1 capturing groups\nâ”œâ”€ (|ðŸ—„...)+ Either |> Capture |> Repeat\nâ”‚  â”œâ”€ a\nâ”‚  â””â”€ b\nâ””â”€ c\n::Tuple{Array{Char,1},Char}\n\njulia> re\"([ab]+c)*\"\n(ðŸ—„)* Sequence |> Capture |> Repeat |> regular expression combinator with 1 capturing groups\nâ”œâ”€ [ab]+  |> Repeat\nâ””â”€ c\n::Array{Tuple{Array{Char,1},Char},1}\n\n\n\n\n\n","category":"macro"},{"location":"lib/public/#CombinedParsers.regex_escape","page":"Public Documentation","title":"CombinedParsers.regex_escape","text":"regex_escape(s::AbstractString)\n\nregular expression metacharacters are escaped along with whitespace.\n\nExamples\n\njulia> regex_escape(\"Bang!\")\n\"Bang\\!\"\njulia> regex_escape(\"  ( [ { . ? *\")\n\"\\ \\ \\(\\ \\[\\ \\{\\ \\.\\ \\?\\ \\*\"\njulia> regex_escape(\"/^[a-z0-9_-]{3,16}$/\")\n\"/\\^\\[a\\-z0\\-9_\\-\\]\\{3,16\\}\\$/\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Parsing,-Logging-and-Side-Effects-1","page":"Public Documentation","title":"Parsing, Logging and Side-Effects","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"parse\nwith_name\nlog_names\nwith_log\ninstrument\nwith_effect","category":"page"},{"location":"lib/public/#Base.parse","page":"Public Documentation","title":"Base.parse","text":"parse(parser::ParserTypes, str::AbstractString)\n\nParse a string with a CombinedParser as an instance of result_type(parser).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.with_name","page":"Public Documentation","title":"CombinedParsers.with_name","text":"with_name(name::Symbol,x; doc=\"\")\n\nA parser labelled with name. Labels are useful in printing and logging.\n\nSee also: @with_names, with_name, log_names\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.log_names","page":"Public Documentation","title":"CombinedParsers.log_names","text":"log_names(x,names=nothing; exclude=nothing)\n\nRebuild parser replacing NamedParser instances with with_log parsers.\n\nSee also: with_log\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.with_log","page":"Public Documentation","title":"CombinedParsers.with_log","text":"with_log(s::AbstractString,p, delta=5;nomatch=false)\n\nLog matching process of parser p, displaying delta characters left of and right of match.\n\nIf nomatch==true, also log when parser does not match.\n\nSee also: log_names, with_effect\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.with_effect","page":"Public Documentation","title":"CombinedParsers.with_effect","text":"with_effect(f::Function,p,a...)\n\nCall f(sequence,before_i,after_i,state,a...) if p matches,  f(sequence,before_i,before_i,nothing,a...) otherwise.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Transformations-1","page":"Public Documentation","title":"Transformations","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"Base.map\nmap_at\nJoinSubstring","category":"page"},{"location":"lib/public/#Base.map","page":"Public Documentation","title":"Base.map","text":"map(f::Function, p::TextParse.AbstractToken, a...)\n\nParser matching p, transforming parsing results (x) with function f(x,a...).\n\nSee also: map_at\n\n\n\n\n\nmap(T::Type, p::TextParse.AbstractToken, a...)\n\nParser matching p, transforming parsing results (x) with constructor T(x,a...).\n\nSee also: map_at\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.map_at","page":"Public Documentation","title":"CombinedParsers.map_at","text":"map_at(f::Function, p, a...)\nmap_at(f::Function, Tc::Type, p, a...)\n\nParser transforming result of a wrapped parser.  a... is passed as additional arguments to f.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.JoinSubstring","page":"Public Documentation","title":"CombinedParsers.JoinSubstring","text":"JoinSubstring(x)\n(!)(x::TextParse.AbstractToken)\n\nParser Transformation getting the matched SubString.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Parser-Constructors-1","page":"Public Documentation","title":"Parser Constructors","text":"","category":"section"},{"location":"lib/public/#Character-Matchers-1","page":"Public Documentation","title":"Character Matchers","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"AnyChar\nCharIn\nCharNotIn","category":"page"},{"location":"lib/public/#CombinedParsers.AnyChar","page":"Public Documentation","title":"CombinedParsers.AnyChar","text":"AnyChar()\n\nParser matching exactly one Char, returning the character.\n\njulia> AnyChar()\nre\".\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.CharIn","page":"Public Documentation","title":"CombinedParsers.CharIn","text":"CharIn(x)\n\nParser matching exactly one character in x.\n\njulia> a_z = CharIn('a':'z')\nre\"[a-z]\"\n\njulia> parse(a_z, \"a\")\n'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n\njulia> ac = CharIn(\"ac\")\nre\"[ac]\"\n\n\njulia> parse(ac, \"c\")\n'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.CharNotIn","page":"Public Documentation","title":"CombinedParsers.CharNotIn","text":"CharNotIn(x)\n\nParser matching exactly one character in x.\n\njulia> a_z = CharNotIn('a':'z')\nre\"[^a-z]\"\n\njulia> parse(a_z, \"a\")\nERROR: ArgumentError: no successfull parsing.\nStacktrace:\n [1] parse(::CharNotIn{Tuple{StepRange{Char,Int64}}}, ::String) at /home/gregor/dev/julia/CombinedParsers/src/CombinedParsers.jl:2583\n [2] top-level scope at REPL[24]:1\n\njulia> ac = CharNotIn(\"ac\")\nre\"[^ac]\"\n\n\njulia> parse(ac, \"c\")\nERROR: ArgumentError: no successfull parsing.\nStacktrace:\n [1] parse(::CharNotIn{Array{Char,1}}, ::String) at /home/gregor/dev/julia/CombinedParsers/src/CombinedParsers.jl:2583\n [2] top-level scope at REPL[24]:1\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Combining-Parser-1","page":"Public Documentation","title":"Combining Parser","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"Either\nBase.(|)\nBase.:| :: Tuple{Either,Type}\nsEither\nSequence\nsSequence\nFlatMap\nafter\nAtomic","category":"page"},{"location":"lib/public/#CombinedParsers.Either","page":"Public Documentation","title":"CombinedParsers.Either","text":"Either(parsers...)\n\nParser that tries matching the provided parsers in order, accepting the first match, and fails if all parsers fail.\n\njulia> match(r\"a|bc\",\"bc\")\nRegexMatch(\"bc\")\n\njulia> parse(Either(\"a\",\"bc\"),\"bc\")\n\"bc\"\n\njulia> parse(\"a\" | \"bc\",\"bc\")\n\"bc\"\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.sEither","page":"Public Documentation","title":"CombinedParsers.sEither","text":"sEither(x...)\n\nSimplifying Either, flattens nested Eithers, remove Never parsers.\n\njulia> Either('a',CharIn(\"AB\")|\"bc\")\n|ðŸ—„... Either\nâ”œâ”€ a\nâ””â”€ |ðŸ—„... Either\n   â”œâ”€ [AB]\n   â””â”€ bc\n::Union{Char, SubString}\n\n\njulia> sEither('a',CharIn(\"AB\")|\"bc\")\n|ðŸ—„... Either\nâ”œâ”€ a\nâ”œâ”€ [AB]\nâ””â”€ bc\n::Union{Char, SubString}\n\n\nSee also Either\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Sequence","page":"Public Documentation","title":"CombinedParsers.Sequence","text":"Sequence(;kw...)\n\nSequence keyword argument constructors transform the parsing into a named tuple.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.sSequence","page":"Public Documentation","title":"CombinedParsers.sSequence","text":"sSequence(x...)\n\nSimplifying Sequence, flatten Sequences, remove Always lookarounds.\n\njulia> Sequence('a',CharIn(\"AB\")*'b')\nðŸ—„ Sequence\nâ”œâ”€ a\nâ””â”€ ðŸ—„ Sequence\n   â”œâ”€ [AB]\n   â””â”€ b\n::Tuple{Char,Tuple{Char,Char}}\n\n\njulia> sSequence('a',CharIn(\"AB\")*'b')\nðŸ—„ Sequence\nâ”œâ”€ a\nâ”œâ”€ [AB]\nâ””â”€ b\n::Tuple{Char,Char,Char}\n\nSee also Sequence\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Atomic","page":"Public Documentation","title":"CombinedParsers.Atomic","text":"Atomic(x)\n\nA parser matching p, and failing when required to backtrack (behaving like an atomic group in regular expressions).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Repeating-1","page":"Public Documentation","title":"Repeating","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"Optional\nBase.(|)(x::TextParse.AbstractToken{T}, default::Union{T,Missing}) where { T }\nRepeat\nRepeat1\nRepeat_stop\nRepeat_until\nBase.join","category":"page"},{"location":"lib/public/#CombinedParsers.Optional","page":"Public Documentation","title":"CombinedParsers.Optional","text":"Optional(parser;default=defaultvalue(result_type(parser)))\n\nParser that always succeeds.  If parser succeeds, return result of parser with curser behind match. If parser does not succeed, return default with curser unchanged.\n\njulia> match(r\"a?\",\"b\")\nRegexMatch(\"\")\n\njulia> parse(Optional(\"a\"),\"b\")\n\"\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.Repeat","page":"Public Documentation","title":"CombinedParsers.Repeat","text":"Repeat(x)\nRepeat(x; min=0,max=typemax(Int))\nRepeat(min::Integer, x)\nRepeat(min::Integer,max::Integer, x)\n\nParser repeating pattern x min:max times.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.Repeat1","page":"Public Documentation","title":"CombinedParsers.Repeat1","text":"Repeat1(x)\n\nParser repeating pattern x one time or more.\n\n\n\n\n\nRepeat1(f::Function,a...)\n\nAbbreviation for map(f,Repeat1(a...)).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Repeat_stop","page":"Public Documentation","title":"CombinedParsers.Repeat_stop","text":"Repeat_stop(p,stop)\n\nRepeat p until stop (NegativeLookahead), not matching stop. Sets cursor before stop. Returns results of p.\n\njulia> p = Repeat_stop(AnyChar(),'b') * AnyChar()\nðŸ—„ Sequence\nâ”œâ”€ ðŸ—„* Sequence |> map(#41) |> Repeat\nâ”‚  â”œâ”€ (?!ðŸ—„)\nâ”‚  â”‚  â””â”€ b\nâ”‚  â””â”€ .\nâ””â”€ .\n::Tuple{Array{Char,1},Char}\n\njulia> parse(p,\"acbX\")\n(['a', 'c'], 'b')\n\nSee also NegativeLookahead\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.Repeat_until","page":"Public Documentation","title":"CombinedParsers.Repeat_until","text":"Repeat\\_until(p,until, with_until=false;wrap=identity)\n\nRepeat p until stop (with Repeat_stop). and set point after stop.\n\nReturn a Vector{result_type(p)} if wrap_until==false, otherwise a Tuple{Vector{result_type(p)},result_type(until)}.\n\nTo transform the Repeat_stop(p) parser head, provide a function(::Vector{result_type(p)}) in wrap keyword argument, e.g.\n\njulia> p = Repeat_until(AnyChar(),'b') * AnyChar()\nðŸ—„ Sequence\nâ”œâ”€ ðŸ—„ Sequence |> map(#41)\nâ”‚  â”œâ”€ ðŸ—„* Sequence |> map(#41) |> Repeat\nâ”‚  â”‚  â”œâ”€ (?!ðŸ—„)\nâ”‚  â”‚  â”‚  â””â”€ b\nâ”‚  â”‚  â””â”€ .\nâ”‚  â””â”€ b\nâ””â”€ .\n::Tuple{Array{Char,1},Char}\n\njulia> parse(p,\"acbX\")\n(['a', 'c'], 'X')\n\njulia> parse(Repeat_until(AnyChar(),'b';wrap=JoinSubstring),\"acbX\")\n\"ac\"\n\nSee also NegativeLookahead\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.join","page":"Public Documentation","title":"Base.join","text":"Base.join(x::Repeat,delim)\n\nParser matching repeated x.parser separated by delim.\n\njulia> parse(join(Repeat(AnyChar()),','),\"a,b,c\")\n3-element Array{Char,1}:\n 'a'\n 'b'\n 'c'\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Assertions-1","page":"Public Documentation","title":"Assertions","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"Always\nNever\nPositiveLookahead\nNegativeLookahead\nPositiveLookbehind\nNegativeLookbehind","category":"page"},{"location":"lib/public/#CombinedParsers.Always","page":"Public Documentation","title":"CombinedParsers.Always","text":"Always()\n\nAssertion parser matching always and not consuming any input. Returns Always().\n\njulia> Always()\nre\"\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.Never","page":"Public Documentation","title":"CombinedParsers.Never","text":"Never()\n\nAssertion parser matching never and not consuming any input.\n\njulia> Never()\nre\"(*FAIL)\"\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.PositiveLookahead","page":"Public Documentation","title":"CombinedParsers.PositiveLookahead","text":"PositiveLookahead(parser)\n\nParser that succeeds if and only if parser succeeds, but consumes no input. The match is returned. Useful for checks like \"must be followed by parser, but don't consume its match\".\n\njulia> la=PositiveLookahead(\"peek\")\nre\"(?=peek)\"\n\n\njulia> parse(la*AnyChar(),\"peek\")\n(re\"(?=peek)\", 'p')\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.NegativeLookahead","page":"Public Documentation","title":"CombinedParsers.NegativeLookahead","text":"NegativeLookahead(parser)\n\nParser that succeeds if and only if parser does not succeed, but consumes no input. parser is returned as match. Useful for checks like \"must not be followed by parser, don't consume its match\".\n\njulia> la = NegativeLookahead(\"peek\")\nre\"(?!peek)\"\n\njulia> parse(la*AnyChar(),\"peek\")\nERROR: ArgumentError: no successfull parsing.\nStacktrace:\n [1] parse(::Sequence{Tuple{SubString,Char},Tuple{NegativeLookahead{SubString,CombinedParsers.ConstantParser{4,SubString}},AnyChar}}, ::String) at /home/gregor/dev/julia/CombinedParsers/src/CombinedParsers.jl:2583\n [2] top-level scope at REPL[24]:1\n\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.PositiveLookbehind","page":"Public Documentation","title":"CombinedParsers.PositiveLookbehind","text":"wraps a parser::P, succeeds if and only if parser succeeds, but consumes no input. The match is returned. Useful for checks like \"must be followed by parser, but don't consume its match\".\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.NegativeLookbehind","page":"Public Documentation","title":"CombinedParsers.NegativeLookbehind","text":"wraps a parser::P, succeeds if and only if parser does not succeed, but consumes no input. nothing is returned as match. Useful for checks like \"must not be followed by parser, don't consume its match\".\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Printing-1","page":"Public Documentation","title":"Printing","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"regex_string\nCombinedParsers.regex_prefix\nCombinedParsers.regex_inner\nCombinedParsers.regex_suffix","category":"page"},{"location":"lib/public/#CombinedParsers.regex_string","page":"Public Documentation","title":"CombinedParsers.regex_string","text":"regex_string(x::AbstractParser)\n\nregex_prefix(x)*regex_inner(x)*regex_suffix(x)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_prefix","page":"Public Documentation","title":"CombinedParsers.regex_prefix","text":"regex_prefix(x)\n\nPrefix printed in parser tree node.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_inner","page":"Public Documentation","title":"CombinedParsers.regex_inner","text":"regex_inner(x::TextParse.AbstractToken)\n\nRegex representation of x. See regex_string\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CombinedParsers.regex_suffix","page":"Public Documentation","title":"CombinedParsers.regex_suffix","text":"regex_suffix(x)\n\nSuffix printed in parser tree node.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Internals-1","page":"Public Documentation","title":"Internals","text":"","category":"section"},{"location":"lib/public/#","page":"Public Documentation","title":"Public Documentation","text":"CombinedParsers.AbstractParser\nCombinedParsers.ConstantParser\nCombinedParsers.NIndexParser\nCombinedParsers.WrappedParser\nCombinedParsers.LookAround\nCombinedParsers._iterate","category":"page"},{"location":"lib/public/#CombinedParsers.AbstractParser","page":"Public Documentation","title":"CombinedParsers.AbstractParser","text":"AbstractParser{T} <: TextParse.AbstractToken{T}\n\nAbstract parser type for parsers returning matches transformed to ::T.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.ConstantParser","page":"Public Documentation","title":"CombinedParsers.ConstantParser","text":"wrapper for stepping with ncodeunit length.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.NIndexParser","page":"Public Documentation","title":"CombinedParsers.NIndexParser","text":"Abstract type for stepping with previndex/nextindex, accounting for ncodeunit length of chars at point.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.WrappedParser","page":"Public Documentation","title":"CombinedParsers.WrappedParser","text":"Abstract type for parser wrappers, providing default methods\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers.LookAround","page":"Public Documentation","title":"CombinedParsers.LookAround","text":"Parsers that do not consume any input can inherit this type\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CombinedParsers._iterate","page":"Public Documentation","title":"CombinedParsers._iterate","text":"parse(p::ParserTypes, s::AbstractString)\n\nparse s with parser p.\n\n\n\n\n\n_iterate(parser, sequence, till, i, states)\n\nNote: i is the index in sequence after parser match according to state (and not the start of the match),  such that start_index(sequence,after,parser,state) returns the start of the matching subsequence, and sequence[start_index(sequence,after,parser,state):prevind(sequence,i)] is the matched subsequence.\n\n\n\n\n\n","category":"function"},{"location":"#CombinedParsers.jl-Documentation-1","page":"Home","title":"CombinedParsers.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A package for combining parsers and transforming strings into julia types.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compose parsers with the functional parser combinator paradigm, utilize Julia's type inferrence for transformations, log conveniently for debugging, and let Julia compile your parser for good performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nPlease read through the Documentation section of the main Julia manual if this is your first time using Julia's documentation system. Once you've read through how to write documentation for your code then come back here.","category":"page"},{"location":"#Package-Features-1","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Clear syntax integrates grammar and transformations with Julia type inference.\nHigher-order parsers depending on the parsing state allow for not context-free parsers.\nAll valid parsings can be iterated lazily.\nInteroperable with TextParse.jl: existing TextParse.AbstractToken implementations can be used with CombinedParsers. CombinedParsers.AbstractParser provide TextParse.tryparsenext and can be used e.g. in CSV.jl.\nParametric parser and state types enable Julia compiler optimizations.\nCompiled regular expression parsers in pure julia are provided with the re_str macro.\nAbstractTrees.jl interface provides colored and clearly layed out printing in the REPL.\nConvenient logging of the parsing process with NamedParsers and SideeffectParsers.\nCombinedParsers generalize from strings to parsing any type supporting getindex, nextind, prevind methods.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The Package Guide provides a tutorial explaining how to get started using CombinedParsers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Some examples of packages using Documenter can be found on the Examples page.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"man/guide.md\",\n    \"man/examples.md\",\n    \"man/syntax.md\",\n    \"man/doctests.md\",\n    \"man/hosting.md\",\n    \"man/latex.md\",\n    \"man/contributing.md\",\n]\nDepth = 1","category":"page"},{"location":"#Library-Outline-1","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]","category":"page"},{"location":"#main-index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"parse(parser, str)","category":"page"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-Started-1","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add https://github.com/gkappler/CombinedParsers.jl","category":"page"},{"location":"#Writing-Parsers-1","page":"Home","title":"Writing Parsers","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CombinedParsers provides constructors to combine parsers and transform (sub-)parsings arbitrarily with julia syntax.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"\"Julia eval for +-*/ operators.\"\nfunction eval_ops((l,opr))\n    for (op,val) in opr\n        l = eval( Expr(:call, Symbol(op), l, val))\n    end\n    l::Rational{Int}\nend\n\nusing TextParse\n@with_names begin\n    number = map(Rational{Int}, TextParse.Numeric(Int))\n    factor = Either(number)  # or expression in parens, see push! below\n    divMul = map(eval_ops,\n                 Sequence( factor, Repeat( CharIn(\"*/\"), factor ) ) )\n    addSub = map(eval_ops,\n\t\t divMul * Repeat( CharIn(\"+-\") * divMul ) )\n    parens = Sequence(2, \"(\",addSub,\")\" )\n    push!(factor, parens)\n    expr = (addSub * AtEnd())[1]\nend;\nparse(log_names(expr), \"1/((1+2)*4+3*(5*2))\")\n","category":"page"},{"location":"#","page":"Home","title":"Home","text":"1//42","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Is every rational answer ultimately the inverse of a universal question in life?","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Combinator constructors are discussed in the user manual.","category":"page"},{"location":"#Regular-expression-syntax-1","page":"Home","title":"Regular expression syntax","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CombinedParsers provides the @re_str macro as a plug-in replacement for the base Julia @r_str macro.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Base Julia PCRE regular expressions:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pattern = r\"reg(ular )?ex(?<a>p(ression)?)?\\??\"i\nmr = match(pattern,\"regexp\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"RegexMatch(\"regexp\", 1=nothing, 2=\"p\", 3=nothing)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CombinedParsers.Regexp regular expression:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using CombinedParsers\nusing CombinedParsers.Regexp\npattern = re\"reg(ular )?ex(?<a>p(ression)?)?\\??\"i\nmre = match(pattern,\"regexp\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ParseMatch(\"Regular Expression?\", 1=\"ular \", 2=\"pression\", 3=\"ression\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The ParseMatch type has getproperty and getindex methods for handling like RegexMatch.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mre.match == mr.match\nmre.captures == mr.captures\nmre[2] == mr[2]\nmre[:a] == mr[:a]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The @re_str supports the following PCRE features","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[X] fundamentals: sequences, alternations, repetitions optional, matches   (*,+,{n}, {min,}, {min,max}, ?)\n[X] escaped characters and generic character types\n[X] character ranges ([])\n[X] non-capturing groups,\n[X] capturing groups, backreferences, subroutines (all by index, relative index and name)\n[X] atomic groups\n[X] lazy repetitions\n[X] conditional expressions\n[X] internal and pattern options setting\n[X] simple assertions (\\A, \\z, \\Z, \\b, \\B, ^, $), \n[X] lookaheads and lookbehinds\n[X] comments","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CombinedParsers.jl is tested against the PCRE C library testset.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"PCRE functionality that is currently not supported:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[ ] capture groups in lookbehinds.\n[ ] ACCEPT, SKIP, COMMIT, THEN, PRUNE, \\K","category":"page"},{"location":"#Parsing-1","page":"Home","title":"Parsing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"match searches for the first match of the Regex in the String and return a RegexMatch/Parsematch object containing the match and captures, or nothing if the match failed. Base.parse methods parse a String into a Julia type. A CombinedParser p will parse into an instance of result_type(p). For parsers defined with the @re_str the result_types are nested Tuples and Vectors of SubString, Chars and Missing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"p = re\"(a)*bc?\"\nparse(p,\"aaab\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(['a','a','a'],'b',missing)","category":"page"},{"location":"#Iterating-1","page":"Home","title":"Iterating","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If a parsing is not uniquely defined different parsings can be lazily iterated.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Backtracking and listing all matches\ncollect(parse_all(re\"^(a|ab|b)+$\",\"abab\"))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"4-element Array{Tuple{AtStart,Array{Union{Char, Tuple{Char,Char}},1},AtEnd},1}:\n (^, ['a', 'b', 'a', 'b'], $)    \n (^, ['a', 'b', ('a', 'b')], $)  \n (^, [('a', 'b'), 'a', 'b'], $)  \n (^, [('a', 'b'), ('a', 'b')], $)","category":"page"},{"location":"#Transformations-1","page":"Home","title":"Transformations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Transform the result of a parsing with map.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"parse(map(length,re\"(ab)*\"),\"abababab\") == 4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"map uses julia type inference to infer the result_type automatically. A supertype T >: result_type(map(f,p)) can be set as result_type with map(f, T, p).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Calling map(::Integer,::AbstractParser) or getindex(::AbstractParser) creates a transforming parser selecting from the result of the parsing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"parse(map(2,re\"abc\"),\"abc\") == 'b'\nparse(re\"abc\"[2],\"abc\") == 'b'","category":"page"}]
}
