<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CombinedParsers.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CombinedParsers.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Package-Features"><span>Package Features</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Useful-Design"><span>Useful Design</span></a></li><li><a class="tocitem" href="#Optimization-Strategy"><span>Optimization Strategy</span></a></li><li><a class="tocitem" href="#Acknowledgements"><span>Acknowledgements</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li><li class="toplevel"><a class="tocitem" href="#Contributing-and-Questions"><span>Contributing and Questions</span></a></li><li><a class="tocitem" href="#Outline"><span>Outline</span></a></li><li><a class="tocitem" href="#main-index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/guide/">Overview</a></li><li><a class="tocitem" href="man/user/">User Guide</a></li><li><a class="tocitem" href="man/example-either-trie/">Prefix-Tree Matching</a></li><li><a class="tocitem" href="man/pcre-compliance/">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="man/example-person/">Names (What is Parsing?)</a></li><li><a class="tocitem" href="man/example-number-ranges/">Number sequences (What are Representations?)</a></li><li><a class="tocitem" href="man/example-arithmetics/">Arithmetics (Evaluation)</a></li><li><a class="tocitem" href="man/pcre/">Regular Expressions</a></li><li><a class="tocitem" href="man/json/">JSON (recursion)</a></li><li><a class="tocitem" href="man/bson/">BSON (<code>Vector{Unit8}</code> parsing)</a></li><li><a class="tocitem" href="man/example-palindromes/">struct Palindrome&lt;:CombinedParser</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public/">Matching/Parsing</a></li><li><a class="tocitem" href="lib/parsers/">Templates</a></li><li><a class="tocitem" href="lib/constructors/">Constructors</a></li><li><a class="tocitem" href="lib/regexp/">Regexp</a></li><li><a class="tocitem" href="man/bnf/">EBNF</a></li><li><a class="tocitem" href="lib/transformation/">Transformations</a></li><li><a class="tocitem" href="lib/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CombinedParsers.jl-Documentation"><a class="docs-heading-anchor" href="#CombinedParsers.jl-Documentation">CombinedParsers.jl Documentation</a><a id="CombinedParsers.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CombinedParsers.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers" href="#CombinedParsers"><code>CombinedParsers</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A package for combining parsers and transforming strings into julia types.</p><p>Compose parsers with the functional <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator paradigm</a>, utilize Julia&#39;s type inferrence for transformations, log conveniently for debugging, and let Julia compile your parser for good performance.</p></div></section></article><p>Compose parsers parsimoneously within a functional <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator paradigm</a>, utilize Julia&#39;s type inference for transformations, log conveniently for debugging, and let Julia compile your parser for performance.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>CombinedParsers.jl</code> is currently a release candidate presented at JuliaCon2020. See the next steps section, if interested.</p></div></div><h2 id="Package-Features"><a class="docs-heading-anchor" href="#Package-Features">Package Features</a><a id="Package-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Features" title="Permalink"></a></h2><h3 id="Speed"><a class="docs-heading-anchor" href="#Speed">Speed</a><a id="Speed-1"></a><a class="docs-heading-anchor-permalink" href="#Speed" title="Permalink"></a></h3><ul><li>optimized julia <code>@generated function</code>s for parametric parser and state types (benchmarks in <a href="man/pcre-compliance/">compliance tests</a>)</li><li>fast trie-based scanning (<a href="man/example-either-trie/">example</a>), compile with your custom parsing algorithm (<a href="man/example-palindromes/">example</a>)</li><li>often matches faster than C library <code>PCRE</code> regular expressions</li><li>memoization with <a href="lib/constructors/#CombinedParsers.WithMemory"><code>WithMemory</code></a></li><li>lazy transformations of match states (for <a href="lib/constructors/#CombinedParsers.Sequence"><code>Sequence</code></a> and <a href="lib/constructors/#CombinedParsers.Repeat"><code>Repeat</code></a>)</li></ul><h3 id="Simplicity"><a class="docs-heading-anchor" href="#Simplicity">Simplicity</a><a id="Simplicity-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicity" title="Permalink"></a></h3><ul><li><a href="lib/constructors/#CombinedParsers.@syntax"><code>@syntax</code></a> defines parser and result construction without redundancy: Julia infers <a href="lib/transformation/#CombinedParsers.result_type"><code>result_type</code></a>(parser) in <a href="lib/transformation/#Base.map"><code>map</code></a>.</li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees.jl</a> printing in the REPL. </li><li><a href="lib/constructors/#CombinedParsers.with_log"><code>with_log</code></a> provides colored logging of the parsing <a href="lib/constructors/#CombinedParsers.with_name"><code>with_name</code></a>s.</li></ul><h3 id="Interoperability"><a class="docs-heading-anchor" href="#Interoperability">Interoperability</a><a id="Interoperability-1"></a><a class="docs-heading-anchor-permalink" href="#Interoperability" title="Permalink"></a></h3><ul><li><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a> can be composed with CombinedParsers and vice versa. </li><li><a href="lib/regexp/#CombinedParsers.Regexp.@re_str"><code>@re_str</code></a> provides pure Julia regular expressions as plug-in replacement for <code>Base.@r_str</code> (<a href="man/pcre-compliance/">PCRE pattern unit test set</a>).</li></ul><h3 id="Generality"><a class="docs-heading-anchor" href="#Generality">Generality</a><a id="Generality-1"></a><a class="docs-heading-anchor-permalink" href="#Generality" title="Permalink"></a></h3><ul><li>Lazily <a href="lib/public/#Base.iterate"><code>iterate</code></a> all valid parsings.</li><li>Higher-order parsers: <a href="lib/constructors/#CombinedParsers.after"><code>after</code></a> matching a left-hand parser a right-hand parser is constructed in arbitrary function of the left-hand match.</li><li>Parse binary data <code>Vector{UInt8}</code> and any sequence type supporting <code>getindex</code>, <code>nextind</code>, <code>prevind</code> methods (cf. <a href="man/bson/">bson example</a>).</li></ul><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p><code>CombinedParsers.jl</code> is a registered package. Install with</p><pre><code class="language-julia hljs">] add CombinedParsers</code></pre><ul><li>The <a href="man/guide/#Overview">Overview</a> provides a tutorial explaining how to get started using CombinedParsers.</li><li>The <a href="man/user/">User guide</a> provides a summary of CombinedParsers types and constructors.</li><li>Some examples of packages using CombinedParsers can be found on the <a href="#Examples">Examples</a> page.</li><li><a href="lib/public/">Matching and parsing</a></li><li><a href="lib/parsers/">Parser Templates</a></li><li><a href="lib/constructors/">Parser Construction</a></li><li><a href="lib/regexp/">composing with regular expressions</a></li><li><a href="lib/transformation/">Transformations</a></li></ul><p>See the <a href="#main-index">Index</a> for the complete list of documented functions and types.</p><p>If you prefer a video introduction:</p><table><tr><th style="text-align: right">8-min JuliaCon2020 talk</th><th style="text-align: right">3h JuliaCon2021 workshop</th></tr><tr><td style="text-align: right"><a href="https://www.youtube.com/watch?v=YBMJSKwwCT0"><img src="https://img.youtube.com/vi/YBMJSKwwCT0/0.jpg" alt="JuliaCon2020 talk"/></a></td><td style="text-align: right"><a href="https://www.youtube.com/watch?v=RpCnP-S7txI"><img src="https://img.youtube.com/vi/RpCnP-S7txI/0.jpg" alt="JuliaCon2021 workshop"/></a></td></tr></table><h3 id="Example:-rational-numbers-arithmetics"><a class="docs-heading-anchor" href="#Example:-rational-numbers-arithmetics">Example: rational numbers arithmetics</a><a id="Example:-rational-numbers-arithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-rational-numbers-arithmetics" title="Permalink"></a></h3><p>Parsing is reading and transforming a sequence of characters. <code>CombinedParsers</code> provides constructors to combine parsers and transform (sub-)parsings arbitrarily with julia syntax.</p><pre><code class="language-julia hljs">using CombinedParsers
using TextParse</code></pre><p>This example reads and evaluates arithmetical terms for rational numbers. The following defines an evaluating parser for rational number terms as sequences of subterms interleaved with operators.</p><p>Subterms are <a href="lib/constructors/#CombinedParsers.Either"><code>Either</code></a> integer numbers, <code>TextParse.Numeric(Int)</code> converted to <code>Rational{Int}</code>, or subterms are written as parentheses around a nested term:</p><pre><code class="language-julia hljs">@syntax subterm = Either{Rational{Int}}(Any[TextParse.Numeric(Int)]; convert=true);
@syntax for parenthesis in subterm
    mult         = evaluate |&gt; join(subterm, CharIn(&quot;*/&quot;), infix=:prefix )
    @syntax term = evaluate |&gt; join(mult,    CharIn(&quot;+-&quot;), infix=:prefix )
    Sequence(2,&#39;(&#39;,term,&#39;)&#39;)
end;</code></pre><p>The <a href="lib/constructors/#CombinedParsers.@syntax"><code>@syntax</code></a> definition in 5,5 lines is sufficient for parsing and evaluating arithmetics: <a href="lib/constructors/#Base.join"><code>Base.join</code></a><code>(x, delimiter; infix=:prefix)</code> is shorthand for <a href="lib/constructors/#CombinedParsers.Sequence"><code>Sequence</code></a><code>(x ,</code><a href="lib/constructors/#CombinedParsers.Repeat"><code>Repeat</code></a><code>( delimiter * x  ))</code>, and <code>f |&gt; parser</code> is shorthand for <a href="lib/transformation/#Base.map"><code>map</code></a><code>(f,parser)</code>. That&#39;s all! <a href="lib/constructors/#CombinedParsers.@syntax"><code>@syntax</code></a> registers a <code>@term_string</code> macro for parsing and transforming:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result_type(term)</code><code class="nohighlight hljs ansi" style="display:block;">Rational{Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; term&quot;(1+2)/5&quot;</code><code class="nohighlight hljs ansi" style="display:block;">3//5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # The defined `CombinedParser` `term` function
       # provides optional logging of the parsing process.
       term(&quot;1/((1+2)*4+3*(5*2))&quot;,log = [:parenthesis])</code><code class="nohighlight hljs ansi" style="display:block;">   match parenthesis@4-9: 1/((1+2)*4+3*(
                             ^___^
   match parenthesis@14-19: *4+3*(5*2))
                                 ^___^
   match parenthesis@3-20: 1/((1+2)*4+3*(5*2))
                             ^_______________^
1//42</code></pre><p><a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)">Is every rational answer ultimately the inverse of a universal question in life?</a></p><p>Note: The <code>evaluate</code> function definition is detailed in <a href="man/example-arithmetics/">the full example</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; evaluate( (0, [ (&#39;+&#39;,1), (&#39;-&#39;,2) ]) )</code><code class="nohighlight hljs ansi" style="display:block;">-1//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; evaluate( (1, [ (&#39;*&#39;,4), (&#39;/&#39;,3) ]) )</code><code class="nohighlight hljs ansi" style="display:block;">4//3</code></pre><h2 id="Useful-Design"><a class="docs-heading-anchor" href="#Useful-Design">Useful Design</a><a id="Useful-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-Design" title="Permalink"></a></h2><ul><li><a href="https://github.com/gkappler/WikitextParser.jl">WikitextParser.jl</a> is a <code>CombinedParser</code> for parsing <a href="https://en.wikipedia.org/wiki/Help:Wikitext">wikitext syntax</a>, quite comprehensibly and representing Wikipedia articles within Julia.</li><li>OrgmodeParser.jl is a <code>CombinedParser</code> for parsing main <a href="https://orgmode.org/">org mode</a> syntax, representing org files within Julia.</li><li><a href="https://github.com/gkappler/CombinedParserTools.jl">CombinedParserTools.jl</a> is currently more or less my own workspace to provide a set of re-useable parsers, used in <code>WikitextParser</code>.</li><li><a href="https://github.com/gkappler/Tries.jl">Tries.jl</a> is the abstract implementation of the fast prefix-tree matching in <code>CombinedParsers</code> (see <a href="https://gkappler.github.io/CombinedParsers.jl/dev/man/example-either-trie/">docs</a>)</li><li><a href="https://github.com/gkappler/ReversedStrings.jl">ReversedStrings.jl</a> implements lazy lazy <code>String</code> transformations and <code>reverse</code> (similar to <a href="https://github.com/JuliaArrays/LazyArrays.jl">LazyArrays.jl</a>)</li></ul><p>If you want to work with any of these open source packages, I will gladly provide professional support. If you are writing your own recursive <code>CombinedParser</code> and seek inspiration, you might find these comprehensive examples interesting. (currently α release, so beware, dragons!)</p><p>The <code>CombinedParsers</code> design </p><ul><li>is fast due to Julia parametric types, and compiler optimizations with generated functions,</li><li>its strictly typed parsing defines the domain data types,</li><li>is composable and optimizable with Julia method dispatch,</li><li>provides flexible public API for parsing, matching, iteration</li></ul><p>Making Julia parametric types central for the parser design equally allows automation of the data pipeline after parsing.</p><p>FilingForest demonstrates indexing the German Wiktionary into a columnar database, with fast selecting and measuring. I am finishing the write-up of Wiktionary data parsing into a language graph database including:</p><ul><li>fast db-indexing of text streams (e.g. logging): If you need support indexing logging streams into a (SQL-)Database, the (currently) proprietary TypeGraphs.jl provides <code>CombinedParsers</code> plug and play: Table schemas are infered from your parser.</li><li>fast out-of core data science/AI on your parsed data: If you need support with storing parsed data in optimized memory-mapped JuliaDB, TypeDB.jl provides <code>CombinedParsers</code> plug and play. </li><li>fast scientific measurements in a data graph: FilingForest IA.jl provides <code>CombinedParsers</code> plug and play: even for recursively nested data.</li></ul><p>All (currently) proprietary packages are default-over-configuration for fast integration, and are in active development.</p><ul><li>fast HTTP-serving of parsed data: If you need support with a parsing server-client infrastructure, the (currently) proprietary GraphQLAlchemy.jl provides <code>CombinedParsers</code> plug and play: GraphQL schemas and resolver are infered from your parser.</li></ul><h2 id="Optimization-Strategy"><a class="docs-heading-anchor" href="#Optimization-Strategy">Optimization Strategy</a><a id="Optimization-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Strategy" title="Permalink"></a></h2><p>With the C PCRE2 library testset, and for 58% of patterns, <code>CombinedParsers</code>  match faster than <code>Regex</code> (first 100 pattern). C PCRE2 optimized is among the fastest regex libraries (<a href="https://github.com/mariomka/regex-benchmark/tree/optimized">second behind Rust</a>, running <a href="https://github.com/mariomka">mariomka</a>&#39;s benchmark will position CombinedParser among its competition). Explorations for optimization are in git branches.</p><blockquote><p>All benchmarks are wrong, but some are useful - <a href="https://github.com/szilard">Szilard</a>, <a href="https://github.com/szilard/benchm-ml">benchm-ml</a></p></blockquote><ul><li><a href="man/pcre-compliance/#Compliance-with-the-PCRE-test-set">Compliance with the PCRE test set</a></li><ul><li><a href="man/pcre-compliance/#PCRE-Unit-Tests">PCRE Unit Tests</a></li><li><a href="man/pcre-compliance/#Performance-Comparison-with-C-PCRE:">Performance Comparison with C PCRE:</a></li></ul></ul><p>The package is maturing, and optimization is ongoing. If you are interested in and able to dive deeper into the Julia memory layout and compiler, I would gladly collaborate on further optimizations:</p><ul><li>String layout: Parsing requires repeated Char comparisons. In UTF8, frequent characters are encoded shorter (8 bit), rare have longer codes. For this reason, in Julia <code>String</code> indices are not consecutive and transversal requires using infamous <code>nextind</code> and <code>prevind</code>. Profiling:<ul><li><code>leftof</code> and <code>rightof</code> comsume considerable time.  <a href="lib/internals/#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a> can speed up that traversal</li><li><code>CombinedParsers</code> currently operates on the result of <code>getindex(::String,index)::Char</code> (technically on <code>iterate(::String,index)::Tuple{Char,Int}</code>).  Could matching use the raw byte representation directly?</li></ul></li><li>Macros: make all iteration <code>@generated</code> functions using expressions generated by a dispatched <code>iterate_expression</code> that can be used in a macro <code>@iterate</code> to generate an unrolled/unnested iteration code. (Profiling hints that function calls do hardly contribute to runtime.)</li></ul><h2 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h2><p>This package is enabled only due to the Julia&#39;s compiler and superior type system. Thankfully: a really concise language for powerful computing!</p><p>I am thankful for contributions and inspiration from many great packages:</p><h3 id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a class="docs-heading-anchor" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a></a><a id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)" title="Permalink"></a></h3><blockquote><p>A bunch of fast text parsing tools, used in CSV.jl</p></blockquote><p><code>CombinedParsers</code> composes with  <a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a> both ways  (<code>CombinedParser &lt;: TextParse.AbstractToken</code> and provides a method for <a href="lib/parsers/#Dates.tryparsenext"><code>CombinedParsers.tryparsenext</code></a>)</p><h3 id="Inspirations"><a class="docs-heading-anchor" href="#Inspirations">Inspirations</a><a id="Inspirations-1"></a><a class="docs-heading-anchor-permalink" href="#Inspirations" title="Permalink"></a></h3><ul><li>The work was strongly inspired by the great Scala <a href="https://github.com/lihaoyi/fastparse">fastparse</a> package, and also the <a href="https://package.elm-lang.org/packages/elm/parser/latest/">elm parser</a>.</li><li><a href="https://github.com/JuliaData/Parsers.jl">Parsers.jl</a>, a collection of parsers for date and primitive types, inspired the <a href="lib/public/#Base.parse"><code>parse</code></a> methods.</li><li><a href="https://github.com/BioJulia/Automa.jl">Automa.jl</a>, a Julia package for text validation, parsing, and tokenizing based on state machine compiler.  The package compiles deterministic finite automata.  (Currently there is no inter-operation possible, because in <code>Automa</code> processing of parsed tokens is done with actions).</li><li><a href="https://github.com/andrewcooke/ParserCombinator.jl">ParserCombinator.jl</a> was a great inspiration. Yet I decided for a new design with a focus on transformations and type inference with parametric types, instead of basing this work off <code>ParserCombinator</code>, written before 2016 (and fixed for Julia 1.0 in 2018). <code>CombinedParsers</code> integrates into the Julia 1.0 Iteration API, small <code>Union{Nothing,T} where T</code> types instead of using Nullables, compiler optimizations and generated functions. I want to provide benchmarks comparisons with <code>ParserCombinator.jl</code>.</li></ul><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><ul><li>[ ] Syntax freeze – your comments are appreciated!</li><li>[ ] decide for a error tracing strategy, backtracking. If you want to collaborate on stepping &amp; debugging, please reach out to me.</li><li>[ ] Performance optimizations</li><li>[ ] streaming</li><li>[ ] test coverage underestimated (PCRE tests are not included in travis)</li><li>[ ] <a href="https://github.com/invenia/BlueStyle"><img src="https://img.shields.io/badge/code%20style-blue-4495d1.svg" alt="Code Style: Blue"/></a></li></ul><h1 id="Contributing-and-Questions"><a class="docs-heading-anchor" href="#Contributing-and-Questions">Contributing and Questions</a><a id="Contributing-and-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing-and-Questions" title="Permalink"></a></h1><p>Contributions and feedback are very welcome,  especially regarding brief syntax and constructor dispatch.  Please open an issue if you encounter any problems or would just like to ask a question, or contact me at mail@g-kappler.de.</p><h2 id="Outline"><a class="docs-heading-anchor" href="#Outline">Outline</a><a id="Outline-1"></a><a class="docs-heading-anchor-permalink" href="#Outline" title="Permalink"></a></h2><h3 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h3><ul><li><a href="man/guide/#Overview">Overview</a></li><ul><li><a href="man/guide/#ParseMatch"><code>ParseMatch</code></a></li><li><a href="man/guide/#Parsing">Parsing</a></li><li><a href="man/guide/#Iterating">Iterating</a></li><li><a href="man/guide/#Performance">Performance</a></li><li><a href="man/guide/#Transformations">Transformations</a></li></ul><li><a href="man/user/#User-Guide">User Guide</a></li><ul><li><a href="man/user/#Basics">Basics</a></li><li><a href="man/user/#Character-Sets">Character Sets</a></li><li><a href="man/user/#Sequence">Sequence</a></li><li><a href="man/user/#Either">Either</a></li><li><a href="man/user/#Repeat">Repeat</a></li><li><a href="man/user/#Optional">Optional</a></li><li><a href="man/user/#Lazy-repetitions-and-optional-parsers">Lazy repetitions and optional parsers</a></li><li><a href="man/user/#Assertions">Assertions</a></li><ul><li><a href="man/user/#AtStart()-and-AtEnd()">AtStart() and AtEnd()</a></li><li><a href="man/user/#Looking-around">Looking around</a></li></ul><li><a href="man/user/#Atomic-groups">Atomic groups</a></li></ul><li><a href="man/example-either-trie/#A-fast-[Trie](https://github.com/gkappler/Tries.jl)-based-parser-for-a-collection-of-literal-Strings.">A fast Trie-based parser for a collection of literal Strings.</a></li><ul><ul><li><a href="man/example-either-trie/#Aho-Corasick-algorithm?">Aho-Corasick algorithm?</a></li></ul></ul></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li><a href="man/example-person/#Names-and-Adresses">Names and Adresses</a></li><ul><li><a href="man/example-person/#Reading,-technically,-is-Parsing">Reading, technically, is Parsing</a></li><ul><li><a href="man/example-person/#Julia-NamedTuples-are-a-great-language-feature!">Julia <code>NamedTuple</code>s are a great language feature!</a></li></ul><li><a href="man/example-person/#Adresses">Adresses</a></li><li><a href="man/example-person/#Person&#39;s-adress-data">Person&#39;s adress data</a></li></ul><li><a href="man/example-number-ranges/#Number-lists-(wikitext-references)">Number lists (wikitext references)</a></li><ul><li><a href="man/example-number-ranges/#Number-ranges">Number ranges</a></li><li><a href="man/example-number-ranges/#Numbers">Numbers</a></li><li><a href="man/example-number-ranges/#Joining-numbers-and-ranges">Joining numbers and ranges</a></li><li><a href="man/example-number-ranges/#Inclusion-in-a-wikitext-parser">Inclusion in a wikitext parser</a></li><li><a href="man/example-number-ranges/#PCRE-papercuts-when-parsing-number-sequences">PCRE papercuts when parsing number sequences</a></li></ul><li><a href="man/pcre/#Regular-Expressions-[CombinedParser](@ref)">Regular Expressions <code>CombinedParser</code></a></li><ul><li><a href="man/pcre/#What-is-a-regular-expression?">What is a regular expression?</a></li><li><a href="man/pcre/#Characters-and-Escaped-Characters">Characters and Escaped Characters</a></li><li><a href="man/pcre/#Repeated-patterns">Repeated patterns</a></li><ul><li><a href="man/pcre/#Number-of-Repetitions:-Transforming-a-Parsing">Number of Repetitions: Transforming a Parsing</a></li></ul><li><a href="man/pcre/#[Either](@ref)"><code>Either</code></a></li><li><a href="man/pcre/#Repeatable-patterns,-[Optional](@ref),-[Lazy](@ref)-and-[Atomic](@ref)">Repeatable patterns, <code>Optional</code>, <code>Lazy</code> and <code>Atomic</code></a></li><li><a href="man/pcre/#[Sequence](@ref)s-and-Alternations"><code>Sequence</code>s and Alternations</a></li><li><a href="man/pcre/#[Capture](@ref)s"><code>Capture</code>s</a></li><li><a href="man/pcre/#[Lookahead](@ref)-and-[Lookbehind](@ref)"><code>Lookahead</code> and <code>Lookbehind</code></a></li><li><a href="man/pcre/#Regular-Expression-Brackets">Regular Expression Brackets</a></li></ul><li><a href="man/example-palindromes/#Palindromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser"><code>Palindromes&lt;:CombinedParser</code>: a Tutorial for writing your combinable Parser</a></li><ul><li><a href="man/example-palindromes/#.-Regular-Expression">1. Regular Expression</a></li><ul><li><a href="man/example-palindromes/#Tree-display-of-regex">Tree display of regex</a></li><li><a href="man/example-palindromes/#Regular-Expression-performance">Regular Expression performance</a></li></ul><li><a href="man/example-palindromes/#.-A-non-word-skipping-Palindrome:CombinedParser">2. A non-word skipping <code>Palindrome&lt;:CombinedParser</code></a></li><ul><li><a href="man/example-palindromes/#Parsing-strategy">Parsing strategy</a></li><ul><li><a href="man/example-palindromes/#Prerequisite:-Skipping-whitespace">Prerequisite: Skipping whitespace</a></li></ul><li><a href="man/example-palindromes/#Subtyping-:-CombinedParser{STATE,RESULT}.">Subtyping <code>&lt;: CombinedParser{STATE,RESULT}</code>.</a></li><li><a href="man/example-palindromes/#Matching:-CombinedParsers._iterate">Matching: <code>CombinedParsers._iterate</code></a></li><li><a href="man/example-palindromes/#Base.prevind-and-Base.nextind"><code>Base.prevind</code> and <code>Base.nextind</code></a></li><li><a href="man/example-palindromes/#match-and-get"><code>match</code> and <code>get</code></a></li><li><a href="man/example-palindromes/#Iterating-through-matches">Iterating through matches</a></li><ul><li><a href="man/example-palindromes/#Iteration-of-smaller-Sub-palindromes">Iteration of smaller Sub-palindromes</a></li></ul><li><a href="man/example-palindromes/#Performance-Optimization">Performance Optimization</a></li><li><a href="man/example-palindromes/#Padding-and-combining">Padding and combining</a></li></ul><li><a href="man/example-palindromes/#Next...">Next...</a></li></ul><li><a href="man/json/#JSON">JSON</a></li></ul><h3 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h3><ul><li><a href="lib/public/#Using-CombinedParsers">Using <code>CombinedParsers</code></a></li><ul><li><a href="lib/public/#Printing">Printing</a></li><li><a href="lib/public/#Matching">Matching</a></li><li><a href="lib/public/#Parsing">Parsing</a></li><li><a href="lib/public/#Iterating-matches">Iterating matches</a></li></ul><li><a href="lib/parsers/#Parser-Templates">Parser Templates</a></li><ul><li><a href="lib/parsers/#Composing-with-TextParse">Composing with <code>TextParse</code></a></li><li><a href="lib/parsers/#Constants-and-Conversion">Constants and Conversion</a></li><li><a href="lib/parsers/#Parser-Building-Blocks">Parser Building Blocks</a></li><li><a href="lib/parsers/#Predefined-Parsers">Predefined Parsers</a></li><ul><li><a href="lib/parsers/#Horizontal-and-Vertical-Space">Horizontal and Vertical Space</a></li><ul><li><a href="lib/parsers/#Trimming-space">Trimming space</a></li><li><a href="lib/parsers/#Matching-Space">Matching Space</a></li><li><a href="lib/parsers/#Words">Words</a></li></ul></ul><li><a href="lib/parsers/#Predefined-Assertions">Predefined Assertions</a></li></ul><li><a href="lib/constructors/#Constructing-Parsers">Constructing Parsers</a></li><ul><li><a href="lib/constructors/#Character-Matchers">Character Matchers</a></li><li><a href="lib/constructors/#Repeating">Repeating</a></li><li><a href="lib/constructors/#Atomic">Atomic</a></li><li><a href="lib/constructors/#Sequences">Sequences</a></li><li><a href="lib/constructors/#Recursive-Parsers-with-[Either](@ref)">Recursive Parsers with <code>Either</code></a></li><li><a href="lib/constructors/#Parser-generating-parsers">Parser generating parsers</a></li><li><a href="lib/constructors/#Assertions">Assertions</a></li><ul><li><a href="lib/constructors/#Look-behind">Look behind</a></li><li><a href="lib/constructors/#Look-ahead">Look ahead</a></li></ul><li><a href="lib/constructors/#Logging-and-Side-Effects">Logging and Side-Effects</a></li><li><a href="lib/constructors/#other">other</a></li><li><a href="lib/transformation/#Transformations-to-any-result_type"><code>Transformation</code>s to any <code>result_type</code></a></li><ul><li><a href="lib/transformation/#String-match-results">String match results</a></li></ul></ul><li><a href="lib/regexp/#PCRE-Regular-expressions">PCRE Regular expressions</a></li><ul><li><a href="lib/regexp/#Constructing-Regular-expressions">Constructing Regular expressions</a></li><li><a href="lib/regexp/#Compatibility-and-Unit-Tests">Compatibility &amp; Unit Tests</a></li><li><a href="lib/regexp/#CombinedParsers.Regexp">CombinedParsers.Regexp</a></li><li><a href="lib/regexp/#Parsing-Options">Parsing Options</a></li><li><a href="lib/regexp/#Regular-Expression-Types">Regular Expression Types</a></li></ul><li><a href="lib/internals/#Internal-API">Internal API</a></li><ul><li><a href="lib/internals/#Iterating">Iterating</a></li></ul><li><a href="lib/internals/#Internal-Types">Internal Types</a></li><ul><li><a href="lib/internals/#Abstract-Parsers">Abstract Parsers</a></li><li><a href="lib/internals/#States">States</a></li><li><a href="lib/internals/#Wrapped-Parsers">Wrapped Parsers</a></li><li><a href="lib/internals/#Printing">Printing</a></li><ul><li><a href="lib/internals/#PCRE">PCRE</a></li></ul><li><a href="lib/internals/#Rewriting-Parsers">Rewriting Parsers</a></li></ul></ul><h2 id="main-index"><a class="docs-heading-anchor" href="#main-index">Index</a><a id="main-index-1"></a><a class="docs-heading-anchor-permalink" href="#main-index" title="Permalink"></a></h2><ul><li><a href="lib/public/#CombinedParsers.match_all"><code>CombinedParsers.match_all</code></a></li><li><a href="lib/public/#CombinedParsers.parse_all"><code>CombinedParsers.parse_all</code></a></li><li><a href="lib/public/#CombinedParsers.tryparse_pos"><code>CombinedParsers.tryparse_pos</code></a></li><li><a href="lib/parsers/#CombinedParsers.DateParser"><code>CombinedParsers.DateParser</code></a></li><li><a href="lib/parsers/#CombinedParsers.DateTimeParser"><code>CombinedParsers.DateTimeParser</code></a></li><li><a href="lib/parsers/#CombinedParsers.caseless"><code>CombinedParsers.caseless</code></a></li><li><a href="lib/parsers/#CombinedParsers.integer_base"><code>CombinedParsers.integer_base</code></a></li><li><a href="lib/parsers/#CombinedParsers.parser"><code>CombinedParsers.parser</code></a></li><li><a href="lib/parsers/#CombinedParsers.trim"><code>CombinedParsers.trim</code></a></li><li><a href="lib/parsers/#CombinedParsers.wrap"><code>CombinedParsers.wrap</code></a></li><li><a href="lib/parsers/#CombinedParsers.NumericParser"><code>CombinedParsers.NumericParser</code></a></li><li><a href="lib/constructors/#CombinedParsers.AnyChar"><code>CombinedParsers.AnyChar</code></a></li><li><a href="lib/constructors/#CombinedParsers.CharIn"><code>CombinedParsers.CharIn</code></a></li><li><a href="lib/constructors/#CombinedParsers.CharNotIn"><code>CombinedParsers.CharNotIn</code></a></li><li><a href="lib/constructors/#CombinedParsers.Delayed"><code>CombinedParsers.Delayed</code></a></li><li><a href="lib/constructors/#CombinedParsers.Lookahead"><code>CombinedParsers.Lookahead</code></a></li><li><a href="lib/constructors/#CombinedParsers.Lookbehind"><code>CombinedParsers.Lookbehind</code></a></li><li><a href="lib/constructors/#CombinedParsers.Repeat1"><code>CombinedParsers.Repeat1</code></a></li><li><a href="lib/constructors/#CombinedParsers.Repeat_stop"><code>CombinedParsers.Repeat_stop</code></a></li><li><a href="lib/constructors/#CombinedParsers.Repeat_until"><code>CombinedParsers.Repeat_until</code></a></li><li><a href="lib/constructors/#CombinedParsers._copy"><code>CombinedParsers._copy</code></a></li><li><a href="lib/constructors/#CombinedParsers._ismatch"><code>CombinedParsers._ismatch</code></a></li><li><a href="lib/constructors/#CombinedParsers.after"><code>CombinedParsers.after</code></a></li><li><a href="lib/constructors/#CombinedParsers.defaultvalue"><code>CombinedParsers.defaultvalue</code></a></li><li><a href="lib/constructors/#CombinedParsers.either_result_type"><code>CombinedParsers.either_result_type</code></a></li><li><a href="lib/constructors/#CombinedParsers.flatten_valuepatterns"><code>CombinedParsers.flatten_valuepatterns</code></a></li><li><a href="lib/constructors/#CombinedParsers.ismatch"><code>CombinedParsers.ismatch</code></a></li><li><a href="lib/constructors/#CombinedParsers.log_names"><code>CombinedParsers.log_names</code></a></li><li><a href="lib/constructors/#CombinedParsers.log_parser"><code>CombinedParsers.log_parser</code></a></li><li><a href="lib/constructors/#CombinedParsers.sSequence"><code>CombinedParsers.sSequence</code></a></li><li><a href="lib/constructors/#CombinedParsers.sequence_result_type"><code>CombinedParsers.sequence_result_type</code></a></li><li><a href="lib/constructors/#CombinedParsers.sequence_state_type"><code>CombinedParsers.sequence_state_type</code></a></li><li><a href="lib/constructors/#CombinedParsers.substitute"><code>CombinedParsers.substitute</code></a></li><li><a href="lib/constructors/#CombinedParsers.with_effect"><code>CombinedParsers.with_effect</code></a></li><li><a href="lib/constructors/#CombinedParsers.with_log"><code>CombinedParsers.with_log</code></a></li><li><a href="lib/constructors/#CombinedParsers.with_name"><code>CombinedParsers.with_name</code></a></li><li><a href="lib/constructors/#CombinedParsers.Always"><code>CombinedParsers.Always</code></a></li><li><a href="lib/constructors/#CombinedParsers.AnyValue"><code>CombinedParsers.AnyValue</code></a></li><li><a href="lib/constructors/#CombinedParsers.AtEnd"><code>CombinedParsers.AtEnd</code></a></li><li><a href="lib/constructors/#CombinedParsers.AtStart"><code>CombinedParsers.AtStart</code></a></li><li><a href="lib/constructors/#CombinedParsers.Atomic"><code>CombinedParsers.Atomic</code></a></li><li><a href="lib/constructors/#CombinedParsers.Bytes"><code>CombinedParsers.Bytes</code></a></li><li><a href="lib/constructors/#CombinedParsers.Either"><code>CombinedParsers.Either</code></a></li><li><a href="lib/constructors/#CombinedParsers.FlatMap"><code>CombinedParsers.FlatMap</code></a></li><li><a href="lib/constructors/#CombinedParsers.Lazy"><code>CombinedParsers.Lazy</code></a></li><li><a href="lib/constructors/#CombinedParsers.MappedSequenceParser"><code>CombinedParsers.MappedSequenceParser</code></a></li><li><a href="lib/constructors/#CombinedParsers.MemoizingParser"><code>CombinedParsers.MemoizingParser</code></a></li><li><a href="lib/constructors/#CombinedParsers.NamedParser"><code>CombinedParsers.NamedParser</code></a></li><li><a href="lib/constructors/#CombinedParsers.NegativeLookahead"><code>CombinedParsers.NegativeLookahead</code></a></li><li><a href="lib/constructors/#CombinedParsers.NegativeLookbehind"><code>CombinedParsers.NegativeLookbehind</code></a></li><li><a href="lib/constructors/#CombinedParsers.Never"><code>CombinedParsers.Never</code></a></li><li><a href="lib/constructors/#CombinedParsers.Optional"><code>CombinedParsers.Optional</code></a></li><li><a href="lib/constructors/#CombinedParsers.PositiveLookahead"><code>CombinedParsers.PositiveLookahead</code></a></li><li><a href="lib/constructors/#CombinedParsers.PositiveLookbehind"><code>CombinedParsers.PositiveLookbehind</code></a></li><li><a href="lib/constructors/#CombinedParsers.Repeat"><code>CombinedParsers.Repeat</code></a></li><li><a href="lib/constructors/#CombinedParsers.Sequence"><code>CombinedParsers.Sequence</code></a></li><li><a href="lib/constructors/#CombinedParsers.UnicodeClass"><code>CombinedParsers.UnicodeClass</code></a></li><li><a href="lib/constructors/#CombinedParsers.ValueIn"><code>CombinedParsers.ValueIn</code></a></li><li><a href="lib/constructors/#CombinedParsers.ValueMatcher"><code>CombinedParsers.ValueMatcher</code></a></li><li><a href="lib/constructors/#CombinedParsers.ValueNotIn"><code>CombinedParsers.ValueNotIn</code></a></li><li><a href="lib/constructors/#CombinedParsers.WithMemory"><code>CombinedParsers.WithMemory</code></a></li><li><a href="lib/transformation/#CombinedParsers._deepmap"><code>CombinedParsers._deepmap</code></a></li><li><a href="lib/transformation/#CombinedParsers.deepmap"><code>CombinedParsers.deepmap</code></a></li><li><a href="lib/transformation/#CombinedParsers.dodeepmap"><code>CombinedParsers.dodeepmap</code></a></li><li><a href="lib/transformation/#CombinedParsers.infer_result_type"><code>CombinedParsers.infer_result_type</code></a></li><li><a href="lib/transformation/#CombinedParsers.result_type"><code>CombinedParsers.result_type</code></a></li><li><a href="lib/transformation/#CombinedParsers.Constant"><code>CombinedParsers.Constant</code></a></li><li><a href="lib/transformation/#CombinedParsers.IndexAt"><code>CombinedParsers.IndexAt</code></a></li><li><a href="lib/transformation/#CombinedParsers.MatchRange"><code>CombinedParsers.MatchRange</code></a></li><li><a href="lib/transformation/#CombinedParsers.MatchedSubSequence"><code>CombinedParsers.MatchedSubSequence</code></a></li><li><a href="lib/transformation/#CombinedParsers.Transformation"><code>CombinedParsers.Transformation</code></a></li><li><a href="lib/regexp/#CombinedParsers._iterate-Tuple{ParserWithCaptures, SequenceWithCaptures, Vararg{Any, N} where N}"><code>CombinedParsers._iterate</code></a></li><li><a href="lib/regexp/#CombinedParsers.regex_escape"><code>CombinedParsers.regex_escape</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.Regcomb"><code>CombinedParsers.Regexp.Regcomb</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.index-Tuple{Subroutine, Any}"><code>CombinedParsers.Regexp.index</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.on_options"><code>CombinedParsers.Regexp.on_options</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.parse_options"><code>CombinedParsers.Regexp.parse_options</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.subroutine_index_reset-Tuple{ParserWithCaptures, Capture}"><code>CombinedParsers.Regexp.subroutine_index_reset</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.with_options"><code>CombinedParsers.Regexp.with_options</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.Backreference"><code>CombinedParsers.Regexp.Backreference</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.Capture"><code>CombinedParsers.Regexp.Capture</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.CharWithOptions"><code>CombinedParsers.Regexp.CharWithOptions</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.Conditional"><code>CombinedParsers.Regexp.Conditional</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.DupSubpatternNumbers"><code>CombinedParsers.Regexp.DupSubpatternNumbers</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.FilterOptions"><code>CombinedParsers.Regexp.FilterOptions</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.MatchingNever"><code>CombinedParsers.Regexp.MatchingNever</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.OnOptionsParser"><code>CombinedParsers.Regexp.OnOptionsParser</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.ParserOptions"><code>CombinedParsers.Regexp.ParserOptions</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.ParserWithCaptures"><code>CombinedParsers.Regexp.ParserWithCaptures</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.SequenceWithCaptures"><code>CombinedParsers.Regexp.SequenceWithCaptures</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.StringWithOptions"><code>CombinedParsers.Regexp.StringWithOptions</code></a></li><li><a href="lib/regexp/#CombinedParsers.Regexp.Subroutine"><code>CombinedParsers.Regexp.Subroutine</code></a></li><li><a href="lib/internals/#CombinedParsers._deepmap_parser"><code>CombinedParsers._deepmap_parser</code></a></li><li><a href="lib/internals/#CombinedParsers._iterate"><code>CombinedParsers._iterate</code></a></li><li><a href="lib/internals/#CombinedParsers._leftof"><code>CombinedParsers._leftof</code></a></li><li><a href="lib/internals/#CombinedParsers._rightof"><code>CombinedParsers._rightof</code></a></li><li><a href="lib/internals/#CombinedParsers.deepmap_parser"><code>CombinedParsers.deepmap_parser</code></a></li><li><a href="lib/internals/#CombinedParsers.leftof"><code>CombinedParsers.leftof</code></a></li><li><a href="lib/internals/#CombinedParsers.parsematch_tuple"><code>CombinedParsers.parsematch_tuple</code></a></li><li><a href="lib/internals/#CombinedParsers.print_constructor"><code>CombinedParsers.print_constructor</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_inner"><code>CombinedParsers.regex_inner</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_prefix"><code>CombinedParsers.regex_prefix</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_string"><code>CombinedParsers.regex_string</code></a></li><li><a href="lib/internals/#CombinedParsers.regex_suffix"><code>CombinedParsers.regex_suffix</code></a></li><li><a href="lib/internals/#CombinedParsers.reinfer"><code>CombinedParsers.reinfer</code></a></li><li><a href="lib/internals/#CombinedParsers.rightof"><code>CombinedParsers.rightof</code></a></li><li><a href="lib/internals/#CombinedParsers.state_type"><code>CombinedParsers.state_type</code></a></li><li><a href="lib/internals/#CombinedParsers.strip_either1"><code>CombinedParsers.strip_either1</code></a></li><li><a href="lib/internals/#CombinedParsers.tuple_pos"><code>CombinedParsers.tuple_pos</code></a></li><li><a href="lib/internals/#CombinedParsers.tuple_state"><code>CombinedParsers.tuple_state</code></a></li><li><a href="lib/internals/#CombinedParsers.Assertion"><code>CombinedParsers.Assertion</code></a></li><li><a href="lib/internals/#CombinedParsers.CombinedParser"><code>CombinedParsers.CombinedParser</code></a></li><li><a href="lib/internals/#CombinedParsers.ConstantParser"><code>CombinedParsers.ConstantParser</code></a></li><li><a href="lib/internals/#CombinedParsers.FilterParser"><code>CombinedParsers.FilterParser</code></a></li><li><a href="lib/internals/#CombinedParsers.LeafParser"><code>CombinedParsers.LeafParser</code></a></li><li><a href="lib/internals/#CombinedParsers.MatchState"><code>CombinedParsers.MatchState</code></a></li><li><a href="lib/internals/#CombinedParsers.MatchesIterator"><code>CombinedParsers.MatchesIterator</code></a></li><li><a href="lib/internals/#CombinedParsers.MemoTreeChildren"><code>CombinedParsers.MemoTreeChildren</code></a></li><li><a href="lib/internals/#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a></li><li><a href="lib/internals/#CombinedParsers.NIndexParser"><code>CombinedParsers.NIndexParser</code></a></li><li><a href="lib/internals/#CombinedParsers.NoMatch"><code>CombinedParsers.NoMatch</code></a></li><li><a href="lib/internals/#CombinedParsers.ParseMatch"><code>CombinedParsers.ParseMatch</code></a></li><li><a href="lib/internals/#CombinedParsers.WrappedAssertion"><code>CombinedParsers.WrappedAssertion</code></a></li><li><a href="lib/internals/#CombinedParsers.WrappedParser"><code>CombinedParsers.WrappedParser</code></a></li><li><a href="lib/internals/#CombinedParsers.Regexp.NoDict"><code>CombinedParsers.Regexp.NoDict</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/guide/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 1 September 2021 11:01">Wednesday 1 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
