<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CombinedParsers.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://gkappler.github.io/CombinedParsers.jl/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">CombinedParsers.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Home</a><ul class="internal"><li><a class="tocitem" href="#Package-Features"><span>Package Features</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Useful-Design"><span>Useful Design</span></a></li><li><a class="tocitem" href="#Optimization-Strategy"><span>Optimization Strategy</span></a></li><li><a class="tocitem" href="#Acknowledgements"><span>Acknowledgements</span></a></li><li><a class="tocitem" href="#Next-Steps"><span>Next Steps</span></a></li><li class="toplevel"><a class="tocitem" href="#Contributing-and-Questions"><span>Contributing and Questions</span></a></li><li><a class="tocitem" href="#Outline"><span>Outline</span></a></li><li><a class="tocitem" href="#main-index"><span>Index</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="man/guide.html">Overview</a></li><li><a class="tocitem" href="man/user.html">User Guide</a></li><li><a class="tocitem" href="man/example-either-trie.html">Prefix-Tree Matching</a></li><li><a class="tocitem" href="man/pcre-compliance.html">PCRE Compliance</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="man/example-person.html">Names (What is Parsing?)</a></li><li><a class="tocitem" href="man/example-number-ranges.html">Number sequences (What are Representations?)</a></li><li><a class="tocitem" href="man/example-arithmetics.html">Arithmetics (Evaluation)</a></li><li><a class="tocitem" href="man/pcre.html">Regular Expressions</a></li><li><a class="tocitem" href="man/json.html">JSON (recursion)</a></li><li><a class="tocitem" href="man/bson.html">BSON (<code>Vector{Unit8}</code> parsing)</a></li><li><a class="tocitem" href="man/example-palindromes.html">struct Palindrome&lt;:CombinedParser</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public.html">Matching/Parsing</a></li><li><a class="tocitem" href="lib/parsers.html">Templates</a></li><li><a class="tocitem" href="lib/constructors.html">Constructors</a></li><li><a class="tocitem" href="lib/regexp.html">Regexp</a></li><li><a class="tocitem" href="man/bnf.html">EBNF</a></li><li><a class="tocitem" href="lib/transformation.html">Transformations</a></li><li><a class="tocitem" href="lib/internals.html">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gkappler/CombinedParsers.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CombinedParsers.jl-Documentation"><a class="docs-heading-anchor" href="#CombinedParsers.jl-Documentation">CombinedParsers.jl Documentation</a><a id="CombinedParsers.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CombinedParsers.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="CombinedParsers" href="#CombinedParsers"><code>CombinedParsers</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A package for combining parsers and transforming strings into julia types.</p><p>Compose parsers with the functional <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator paradigm</a>, utilize Julia&#39;s type inferrence for transformations, log conveniently for debugging, and let Julia compile your parser for good performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gkappler/CombinedParsers.jl/blob/a8a7e95da3fe7fc91c5702b87f231f3ea3d6dee7/src/CombinedParsers.jl#LL6-L12">source</a></section></article><p>Compose parsers parsimoneously within a functional <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator paradigm</a>, utilize Julia&#39;s type inference for transformations, log conveniently for debugging, and let Julia compile your parser for performance.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>CombinedParsers.jl</code> is currently a release candidate presented at JuliaCon2020. See the next steps section, if interested.</p></div></div><h2 id="Package-Features"><a class="docs-heading-anchor" href="#Package-Features">Package Features</a><a id="Package-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Features" title="Permalink"></a></h2><h3 id="Speed"><a class="docs-heading-anchor" href="#Speed">Speed</a><a id="Speed-1"></a><a class="docs-heading-anchor-permalink" href="#Speed" title="Permalink"></a></h3><ul><li>optimized julia <code>@generated function</code>s for parametric parser and state types (benchmarks in <a href="man/pcre-compliance.html">compliance tests</a>)</li><li>fast trie-based scanning (<a href="man/example-either-trie.html">example</a>), compile with your custom parsing algorithm (<a href="man/example-palindromes.html">example</a>)</li><li>often matches faster than C library <code>PCRE</code> regular expressions</li><li>memoization with <a href="lib/constructors.html#CombinedParsers.WithMemory"><code>WithMemory</code></a></li><li>lazy transformations of match states (for <a href="lib/constructors.html#CombinedParsers.Sequence"><code>Sequence</code></a> and <a href="lib/constructors.html#CombinedParsers.Repeat"><code>Repeat</code></a>)</li></ul><h3 id="Simplicity"><a class="docs-heading-anchor" href="#Simplicity">Simplicity</a><a id="Simplicity-1"></a><a class="docs-heading-anchor-permalink" href="#Simplicity" title="Permalink"></a></h3><ul><li><a href="lib/constructors.html#CombinedParsers.@syntax"><code>@syntax</code></a> defines parser and result construction without redundancy: Julia infers <a href="lib/transformation.html#CombinedParsers.result_type"><code>result_type</code></a>(parser) in <a href="lib/transformation.html#Base.map"><code>map</code></a>.</li><li><a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees.jl</a> printing in the REPL. </li><li><a href="lib/constructors.html#CombinedParsers.with_log"><code>with_log</code></a> provides colored logging of the parsing <a href="lib/constructors.html#CombinedParsers.with_name"><code>with_name</code></a>s.</li></ul><h3 id="Interoperability"><a class="docs-heading-anchor" href="#Interoperability">Interoperability</a><a id="Interoperability-1"></a><a class="docs-heading-anchor-permalink" href="#Interoperability" title="Permalink"></a></h3><ul><li><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a> can be composed with CombinedParsers and vice versa. </li><li><a href="lib/regexp.html#CombinedParsers.Regexp.@re_str"><code>@re_str</code></a> provides pure Julia regular expressions as plug-in replacement for <code>Base.@r_str</code> (<a href="man/pcre-compliance.html">PCRE pattern unit test set</a>).</li></ul><h3 id="Generality"><a class="docs-heading-anchor" href="#Generality">Generality</a><a id="Generality-1"></a><a class="docs-heading-anchor-permalink" href="#Generality" title="Permalink"></a></h3><ul><li>Lazily <a href="lib/public.html#Base.iterate"><code>iterate</code></a> all valid parsings.</li><li>Higher-order parsers: <a href="lib/constructors.html#CombinedParsers.after"><code>after</code></a> matching a left-hand parser a right-hand parser is constructed in arbitrary function of the left-hand match.</li><li>Parse binary data <code>Vector{UInt8}</code> and any sequence type supporting <code>getindex</code>, <code>nextind</code>, <code>prevind</code> methods (cf. <a href="man/bson.html">bson example</a>).</li></ul><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p><code>CombinedParsers.jl</code> is a registered package. Install with</p><pre><code class="language-julia hljs">] add CombinedParsers</code></pre><ul><li>The <a href="man/guide.html#Overview">Overview</a> provides a tutorial explaining how to get started using CombinedParsers.</li><li>The <a href="man/user.html">User guide</a> provides a summary of CombinedParsers types and constructors.</li><li>Some examples of packages using CombinedParsers can be found on the <a href="index.html#Examples">Examples</a> page.</li><li><a href="lib/public.html">Matching and parsing</a></li><li><a href="lib/parsers.html">Parser Templates</a></li><li><a href="lib/constructors.html">Parser Construction</a></li><li><a href="lib/regexp.html">composing with regular expressions</a></li><li><a href="lib/transformation.html">Transformations</a></li></ul><p>See the <a href="index.html#main-index">Index</a> for the complete list of documented functions and types.</p><p>If you prefer a video introduction:</p><table><tr><th style="text-align: right">8-min JuliaCon2020 talk</th><th style="text-align: right">3h JuliaCon2021 workshop</th></tr><tr><td style="text-align: right"><a href="https://www.youtube.com/watch?v=YBMJSKwwCT0"><img src="https://img.youtube.com/vi/YBMJSKwwCT0/0.jpg" alt="JuliaCon2020 talk"/></a></td><td style="text-align: right"><a href="https://www.youtube.com/watch?v=RpCnP-S7txI"><img src="https://img.youtube.com/vi/RpCnP-S7txI/0.jpg" alt="JuliaCon2021 workshop"/></a></td></tr></table><h3 id="Example:-rational-numbers-arithmetics"><a class="docs-heading-anchor" href="#Example:-rational-numbers-arithmetics">Example: rational numbers arithmetics</a><a id="Example:-rational-numbers-arithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-rational-numbers-arithmetics" title="Permalink"></a></h3><p>Parsing is reading and transforming a sequence of characters. <code>CombinedParsers</code> provides constructors to combine parsers and transform (sub-)parsings arbitrarily with julia syntax.</p><pre><code class="language-julia hljs">using CombinedParsers
using TextParse</code></pre><p>This example reads and evaluates arithmetical terms for rational numbers. The following defines an evaluating parser for rational number terms as sequences of subterms interleaved with operators.</p><p>Subterms are <a href="lib/constructors.html#CombinedParsers.Either"><code>Either</code></a> integer numbers, <code>TextParse.Numeric(Int)</code> converted to <code>Rational{Int}</code>, or subterms are written as parentheses around a nested term:</p><pre><code class="language-julia hljs">@syntax subterm = Either{Rational{Int}}(Any[TextParse.Numeric(Int)]; convert=true);
@syntax for parenthesis in subterm
    mult         = evaluate |&gt; join(subterm, CharIn(&quot;*/&quot;), infix=:prefix )
    @syntax term = evaluate |&gt; join(mult,    CharIn(&quot;+-&quot;), infix=:prefix )
    Sequence(2,&#39;(&#39;,term,&#39;)&#39;)
end;</code></pre><p>The <a href="lib/constructors.html#CombinedParsers.@syntax"><code>@syntax</code></a> definition in 5,5 lines is sufficient for parsing and evaluating arithmetics: <a href="lib/constructors.html#Base.join"><code>Base.join</code></a><code>(x, delimiter; infix=:prefix)</code> is shorthand for <a href="lib/constructors.html#CombinedParsers.Sequence"><code>Sequence</code></a><code>(x ,</code><a href="lib/constructors.html#CombinedParsers.Repeat"><code>Repeat</code></a><code>( delimiter * x  ))</code>, and <code>f |&gt; parser</code> is shorthand for <a href="lib/transformation.html#Base.map"><code>map</code></a><code>(f,parser)</code>. That&#39;s all! <a href="lib/constructors.html#CombinedParsers.@syntax"><code>@syntax</code></a> registers a <code>@term_string</code> macro for parsing and transforming:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; result_type(term)</code><code class="nohighlight hljs ansi" style="display:block;">Rational{Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; term&quot;(1+2)/5&quot;</code><code class="nohighlight hljs ansi" style="display:block;">3//5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # The defined `CombinedParser` `term` function
       # provides optional logging of the parsing process.
       term(&quot;1/((1+2)*4+3*(5*2))&quot;,log = [:parenthesis])</code><code class="nohighlight hljs ansi" style="display:block;">   match parenthesis@4-9: 1/((1+2)*4+3*(
                             ^___^
   match parenthesis@14-19: *4+3*(5*2))
                                 ^___^
   match parenthesis@3-20: 1/((1+2)*4+3*(5*2))
                             ^_______________^
1//42</code></pre><p><a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)">Is every rational answer ultimately the inverse of a universal question in life?</a></p><p>Note: The <code>evaluate</code> function definition is detailed in <a href="man/example-arithmetics.html">the full example</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; evaluate( (0, [ (&#39;+&#39;,1), (&#39;-&#39;,2) ]) )</code><code class="nohighlight hljs ansi" style="display:block;">-1//1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; evaluate( (1, [ (&#39;*&#39;,4), (&#39;/&#39;,3) ]) )</code><code class="nohighlight hljs ansi" style="display:block;">4//3</code></pre><h2 id="Useful-Design"><a class="docs-heading-anchor" href="#Useful-Design">Useful Design</a><a id="Useful-Design-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-Design" title="Permalink"></a></h2><ul><li><a href="https://github.com/gkappler/WikitextParser.jl">WikitextParser.jl</a> is a <code>CombinedParser</code> for parsing <a href="https://en.wikipedia.org/wiki/Help:Wikitext">wikitext syntax</a>, quite comprehensibly and representing Wikipedia articles within Julia.</li><li>OrgmodeParser.jl is a <code>CombinedParser</code> for parsing main <a href="https://orgmode.org/">org mode</a> syntax, representing org files within Julia.</li><li><a href="https://github.com/gkappler/CombinedParserTools.jl">CombinedParserTools.jl</a> is currently more or less my own workspace to provide a set of re-useable parsers, used in <code>WikitextParser</code>.</li><li><a href="https://github.com/gkappler/Tries.jl">Tries.jl</a> is the abstract implementation of the fast prefix-tree matching in <code>CombinedParsers</code> (see <a href="https://gkappler.github.io/CombinedParsers.jl/dev/man/example-either-trie/">docs</a>)</li><li><a href="https://github.com/gkappler/ReversedStrings.jl">ReversedStrings.jl</a> implements lazy lazy <code>String</code> transformations and <code>reverse</code> (similar to <a href="https://github.com/JuliaArrays/LazyArrays.jl">LazyArrays.jl</a>)</li></ul><p>If you want to work with any of these open source packages, I will gladly provide professional support. If you are writing your own recursive <code>CombinedParser</code> and seek inspiration, you might find these comprehensive examples interesting. (currently α release, so beware, dragons!)</p><p>The <code>CombinedParsers</code> design </p><ul><li>is fast due to Julia parametric types, and compiler optimizations with generated functions,</li><li>its strictly typed parsing defines the domain data types,</li><li>is composable and optimizable with Julia method dispatch,</li><li>provides flexible public API for parsing, matching, iteration</li></ul><p>Making Julia parametric types central for the parser design equally allows automation of the data pipeline after parsing.</p><p>FilingForest demonstrates indexing the German Wiktionary into a columnar database, with fast selecting and measuring. I am finishing the write-up of Wiktionary data parsing into a language graph database including:</p><ul><li>fast db-indexing of text streams (e.g. logging): If you need support indexing logging streams into a (SQL-)Database, the (currently) proprietary TypeGraphs.jl provides <code>CombinedParsers</code> plug and play: Table schemas are infered from your parser.</li><li>fast out-of core data science/AI on your parsed data: If you need support with storing parsed data in optimized memory-mapped JuliaDB, TypeDB.jl provides <code>CombinedParsers</code> plug and play. </li><li>fast scientific measurements in a data graph: FilingForest IA.jl provides <code>CombinedParsers</code> plug and play: even for recursively nested data.</li></ul><p>All (currently) proprietary packages are default-over-configuration for fast integration, and are in active development.</p><ul><li>fast HTTP-serving of parsed data: If you need support with a parsing server-client infrastructure, the (currently) proprietary GraphQLAlchemy.jl provides <code>CombinedParsers</code> plug and play: GraphQL schemas and resolver are infered from your parser.</li></ul><h2 id="Optimization-Strategy"><a class="docs-heading-anchor" href="#Optimization-Strategy">Optimization Strategy</a><a id="Optimization-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Strategy" title="Permalink"></a></h2><p>With the C PCRE2 library testset, and for 58% of patterns, <code>CombinedParsers</code>  match faster than <code>Regex</code> (first 100 pattern). C PCRE2 optimized is among the fastest regex libraries (<a href="https://github.com/mariomka/regex-benchmark/tree/optimized">second behind Rust</a>, running <a href="https://github.com/mariomka">mariomka</a>&#39;s benchmark will position CombinedParser among its competition). Explorations for optimization are in git branches.</p><blockquote><p>All benchmarks are wrong, but some are useful - <a href="https://github.com/szilard">Szilard</a>, <a href="https://github.com/szilard/benchm-ml">benchm-ml</a></p></blockquote><ul><li><a href="man/pcre-compliance.html#Compliance-with-the-PCRE-test-set">Compliance with the PCRE test set</a></li><ul><li><a href="man/pcre-compliance.html#PCRE-Unit-Tests">PCRE Unit Tests</a></li><li><a href="man/pcre-compliance.html#Performance-Comparison-with-C-PCRE:">Performance Comparison with C PCRE:</a></li></ul></ul><p>The package is maturing, and optimization is ongoing. If you are interested in and able to dive deeper into the Julia memory layout and compiler, I would gladly collaborate on further optimizations:</p><ul><li>String layout: Parsing requires repeated Char comparisons. In UTF8, frequent characters are encoded shorter (8 bit), rare have longer codes. For this reason, in Julia <code>String</code> indices are not consecutive and transversal requires using infamous <code>nextind</code> and <code>prevind</code>. Profiling:<ul><li><code>leftof</code> and <code>rightof</code> comsume considerable time.  <a href="lib/internals.html#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a> can speed up that traversal</li><li><code>CombinedParsers</code> currently operates on the result of <code>getindex(::String,index)::Char</code> (technically on <code>iterate(::String,index)::Tuple{Char,Int}</code>).  Could matching use the raw byte representation directly?</li></ul></li><li>Macros: make all iteration <code>@generated</code> functions using expressions generated by a dispatched <code>iterate_expression</code> that can be used in a macro <code>@iterate</code> to generate an unrolled/unnested iteration code. (Profiling hints that function calls do hardly contribute to runtime.)</li></ul><h2 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h2><p>This package is enabled only due to the Julia&#39;s compiler and superior type system. Thankfully: a really concise language for powerful computing!</p><p>I am thankful for contributions and inspiration from many great packages:</p><h3 id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a class="docs-heading-anchor" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)"><a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a></a><a id="[TextParse.jl](https://github.com/queryverse/TextParse.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#[TextParse.jl](https://github.com/queryverse/TextParse.jl)" title="Permalink"></a></h3><blockquote><p>A bunch of fast text parsing tools, used in CSV.jl</p></blockquote><p><code>CombinedParsers</code> composes with  <a href="https://github.com/queryverse/TextParse.jl">TextParse.jl</a> both ways  (<code>CombinedParser &lt;: TextParse.AbstractToken</code> and provides a method for <a href="lib/parsers.html#Dates.tryparsenext"><code>CombinedParsers.tryparsenext</code></a>)</p><h3 id="Inspirations"><a class="docs-heading-anchor" href="#Inspirations">Inspirations</a><a id="Inspirations-1"></a><a class="docs-heading-anchor-permalink" href="#Inspirations" title="Permalink"></a></h3><ul><li>The work was strongly inspired by the great Scala <a href="https://github.com/lihaoyi/fastparse">fastparse</a> package, and also the <a href="https://package.elm-lang.org/packages/elm/parser/latest/">elm parser</a>.</li><li><a href="https://github.com/JuliaData/Parsers.jl">Parsers.jl</a>, a collection of parsers for date and primitive types, inspired the <a href="lib/public.html#Base.parse"><code>parse</code></a> methods.</li><li><a href="https://github.com/BioJulia/Automa.jl">Automa.jl</a>, a Julia package for text validation, parsing, and tokenizing based on state machine compiler.  The package compiles deterministic finite automata.  (Currently there is no inter-operation possible, because in <code>Automa</code> processing of parsed tokens is done with actions).</li><li><a href="https://github.com/andrewcooke/ParserCombinator.jl">ParserCombinator.jl</a> was a great inspiration. Yet I decided for a new design with a focus on transformations and type inference with parametric types, instead of basing this work off <code>ParserCombinator</code>, written before 2016 (and fixed for Julia 1.0 in 2018). <code>CombinedParsers</code> integrates into the Julia 1.0 Iteration API, small <code>Union{Nothing,T} where T</code> types instead of using Nullables, compiler optimizations and generated functions. I want to provide benchmarks comparisons with <code>ParserCombinator.jl</code>.</li></ul><h2 id="Next-Steps"><a class="docs-heading-anchor" href="#Next-Steps">Next Steps</a><a id="Next-Steps-1"></a><a class="docs-heading-anchor-permalink" href="#Next-Steps" title="Permalink"></a></h2><ul><li>[ ] Syntax freeze – your comments are appreciated!</li><li>[ ] decide for a error tracing strategy, backtracking. If you want to collaborate on stepping &amp; debugging, please reach out to me.</li><li>[ ] Performance optimizations</li><li>[ ] streaming</li><li>[ ] test coverage underestimated (PCRE tests are not included in travis)</li><li>[ ] <a href="https://github.com/invenia/BlueStyle"><img src="https://img.shields.io/badge/code%20style-blue-4495d1.svg" alt="Code Style: Blue"/></a></li></ul><h1 id="Contributing-and-Questions"><a class="docs-heading-anchor" href="#Contributing-and-Questions">Contributing and Questions</a><a id="Contributing-and-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing-and-Questions" title="Permalink"></a></h1><p>Contributions and feedback are very welcome,  especially regarding brief syntax and constructor dispatch.  Please open an issue if you encounter any problems or would just like to ask a question, or contact me at mail@g-kappler.de.</p><h2 id="Outline"><a class="docs-heading-anchor" href="#Outline">Outline</a><a id="Outline-1"></a><a class="docs-heading-anchor-permalink" href="#Outline" title="Permalink"></a></h2><h3 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h3><ul><li><a href="man/guide.html#Overview">Overview</a></li><ul><li><a href="man/guide.html#ParseMatch"><code>ParseMatch</code></a></li><li><a href="man/guide.html#Parsing">Parsing</a></li><li><a href="man/guide.html#Iterating">Iterating</a></li><li><a href="man/guide.html#Performance">Performance</a></li><li><a href="man/guide.html#Transformations">Transformations</a></li></ul><li><a href="man/user.html#User-Guide">User Guide</a></li><ul><li><a href="man/user.html#Basics">Basics</a></li><li><a href="man/user.html#Character-Sets">Character Sets</a></li><li><a href="man/user.html#Sequence">Sequence</a></li><li><a href="man/user.html#Either">Either</a></li><li><a href="man/user.html#Repeat">Repeat</a></li><li><a href="man/user.html#Optional">Optional</a></li><li><a href="man/user.html#Lazy-repetitions-and-optional-parsers">Lazy repetitions and optional parsers</a></li><li><a href="man/user.html#Assertions">Assertions</a></li><ul><li><a href="man/user.html#AtStart()-and-AtEnd()">AtStart() and AtEnd()</a></li><li><a href="man/user.html#Looking-around">Looking around</a></li></ul><li><a href="man/user.html#Atomic-groups">Atomic groups</a></li></ul><li><a href="man/example-either-trie.html#A-fast-[Trie](https://github.com/gkappler/Tries.jl)-based-parser-for-a-collection-of-literal-Strings.">A fast Trie-based parser for a collection of literal Strings.</a></li><ul><ul><li><a href="man/example-either-trie.html#Aho-Corasick-algorithm?">Aho-Corasick algorithm?</a></li></ul></ul></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li><a href="man/example-person.html#Names-and-Adresses">Names and Adresses</a></li><ul><li><a href="man/example-person.html#Reading,-technically,-is-Parsing">Reading, technically, is Parsing</a></li><ul><li><a href="man/example-person.html#Julia-NamedTuples-are-a-great-language-feature!">Julia <code>NamedTuple</code>s are a great language feature!</a></li></ul><li><a href="man/example-person.html#Adresses">Adresses</a></li><li><a href="man/example-person.html#Person&#39;s-adress-data">Person&#39;s adress data</a></li></ul><li><a href="man/example-number-ranges.html#Number-lists-(wikitext-references)">Number lists (wikitext references)</a></li><ul><li><a href="man/example-number-ranges.html#Number-ranges">Number ranges</a></li><li><a href="man/example-number-ranges.html#Numbers">Numbers</a></li><li><a href="man/example-number-ranges.html#Joining-numbers-and-ranges">Joining numbers and ranges</a></li><li><a href="man/example-number-ranges.html#Inclusion-in-a-wikitext-parser">Inclusion in a wikitext parser</a></li><li><a href="man/example-number-ranges.html#PCRE-papercuts-when-parsing-number-sequences">PCRE papercuts when parsing number sequences</a></li></ul><li><a href="man/pcre.html#Regular-Expressions-[CombinedParser](@ref)">Regular Expressions <code>CombinedParser</code></a></li><ul><li><a href="man/pcre.html#What-is-a-regular-expression?">What is a regular expression?</a></li><li><a href="man/pcre.html#Characters-and-Escaped-Characters">Characters and Escaped Characters</a></li><li><a href="man/pcre.html#Repeated-patterns">Repeated patterns</a></li><ul><li><a href="man/pcre.html#Number-of-Repetitions:-Transforming-a-Parsing">Number of Repetitions: Transforming a Parsing</a></li></ul><li><a href="man/pcre.html#[Either](@ref)"><code>Either</code></a></li><li><a href="man/pcre.html#Repeatable-patterns,-[Optional](@ref),-[Lazy](@ref)-and-[Atomic](@ref)">Repeatable patterns, <code>Optional</code>, <code>Lazy</code> and <code>Atomic</code></a></li><li><a href="man/pcre.html#[Sequence](@ref)s-and-Alternations"><code>Sequence</code>s and Alternations</a></li><li><a href="man/pcre.html#[Capture](@ref)s"><code>Capture</code>s</a></li><li><a href="man/pcre.html#[Lookahead](@ref)-and-[Lookbehind](@ref)"><code>Lookahead</code> and <code>Lookbehind</code></a></li><li><a href="man/pcre.html#Regular-Expression-Brackets">Regular Expression Brackets</a></li></ul><li><a href="man/example-palindromes.html#Palindromes:CombinedParser:-a-Tutorial-for-writing-your-combinable-Parser"><code>Palindromes&lt;:CombinedParser</code>: a Tutorial for writing your combinable Parser</a></li><ul><li><a href="man/example-palindromes.html#.-Regular-Expression">1. Regular Expression</a></li><ul><li><a href="man/example-palindromes.html#Tree-display-of-regex">Tree display of regex</a></li><li><a href="man/example-palindromes.html#Regular-Expression-performance">Regular Expression performance</a></li></ul><li><a href="man/example-palindromes.html#.-A-non-word-skipping-Palindrome:CombinedParser">2. A non-word skipping <code>Palindrome&lt;:CombinedParser</code></a></li><ul><li><a href="man/example-palindromes.html#Parsing-strategy">Parsing strategy</a></li><ul><li><a href="man/example-palindromes.html#Prerequisite:-Skipping-whitespace">Prerequisite: Skipping whitespace</a></li></ul><li><a href="man/example-palindromes.html#Subtyping-:-CombinedParser{STATE,RESULT}.">Subtyping <code>&lt;: CombinedParser{STATE,RESULT}</code>.</a></li><li><a href="man/example-palindromes.html#Matching:-CombinedParsers._iterate">Matching: <code>CombinedParsers._iterate</code></a></li><li><a href="man/example-palindromes.html#Base.prevind-and-Base.nextind"><code>Base.prevind</code> and <code>Base.nextind</code></a></li><li><a href="man/example-palindromes.html#match-and-get"><code>match</code> and <code>get</code></a></li><li><a href="man/example-palindromes.html#Iterating-through-matches">Iterating through matches</a></li><ul><li><a href="man/example-palindromes.html#Iteration-of-smaller-Sub-palindromes">Iteration of smaller Sub-palindromes</a></li></ul><li><a href="man/example-palindromes.html#Performance-Optimization">Performance Optimization</a></li><li><a href="man/example-palindromes.html#Padding-and-combining">Padding and combining</a></li></ul><li><a href="man/example-palindromes.html#Next...">Next...</a></li></ul><li><a href="man/json.html#JSON">JSON</a></li></ul><h3 id="Library-API"><a class="docs-heading-anchor" href="#Library-API">Library API</a><a id="Library-API-1"></a><a class="docs-heading-anchor-permalink" href="#Library-API" title="Permalink"></a></h3><ul><li><a href="lib/public.html#Using-CombinedParsers">Using <code>CombinedParsers</code></a></li><ul><li><a href="lib/public.html#Printing">Printing</a></li><li><a href="lib/public.html#Matching">Matching</a></li><li><a href="lib/public.html#Parsing">Parsing</a></li><li><a href="lib/public.html#Iterating-matches">Iterating matches</a></li></ul><li><a href="lib/parsers.html#Parser-Templates">Parser Templates</a></li><ul><li><a href="lib/parsers.html#Composing-with-TextParse">Composing with <code>TextParse</code></a></li><li><a href="lib/parsers.html#Constants-and-Conversion">Constants and Conversion</a></li><li><a href="lib/parsers.html#Parser-Building-Blocks">Parser Building Blocks</a></li><li><a href="lib/parsers.html#Predefined-Parsers">Predefined Parsers</a></li><ul><li><a href="lib/parsers.html#Horizontal-and-Vertical-Space">Horizontal and Vertical Space</a></li><ul><li><a href="lib/parsers.html#Trimming-space">Trimming space</a></li><li><a href="lib/parsers.html#Matching-Space">Matching Space</a></li><li><a href="lib/parsers.html#Words">Words</a></li></ul></ul><li><a href="lib/parsers.html#Predefined-Assertions">Predefined Assertions</a></li></ul><li><a href="lib/constructors.html#Constructing-Parsers">Constructing Parsers</a></li><ul><li><a href="lib/constructors.html#Character-Matchers">Character Matchers</a></li><li><a href="lib/constructors.html#Repeating">Repeating</a></li><li><a href="lib/constructors.html#Atomic">Atomic</a></li><li><a href="lib/constructors.html#Sequences">Sequences</a></li><li><a href="lib/constructors.html#Recursive-Parsers-with-[Either](@ref)">Recursive Parsers with <code>Either</code></a></li><li><a href="lib/constructors.html#Parser-generating-parsers">Parser generating parsers</a></li><li><a href="lib/constructors.html#Assertions">Assertions</a></li><ul><li><a href="lib/constructors.html#Look-behind">Look behind</a></li><li><a href="lib/constructors.html#Look-ahead">Look ahead</a></li></ul><li><a href="lib/constructors.html#Logging-and-Side-Effects">Logging and Side-Effects</a></li><li><a href="lib/constructors.html#other">other</a></li><li><a href="lib/transformation.html#Transformations-to-any-result_type"><code>Transformation</code>s to any <code>result_type</code></a></li><ul><li><a href="lib/transformation.html#String-match-results">String match results</a></li></ul></ul><li><a href="lib/regexp.html#PCRE-Regular-expressions">PCRE Regular expressions</a></li><ul><li><a href="lib/regexp.html#Constructing-Regular-expressions">Constructing Regular expressions</a></li><li><a href="lib/regexp.html#Compatibility-and-Unit-Tests">Compatibility &amp; Unit Tests</a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp">CombinedParsers.Regexp</a></li><li><a href="lib/regexp.html#Parsing-Options">Parsing Options</a></li><li><a href="lib/regexp.html#Regular-Expression-Types">Regular Expression Types</a></li></ul><li><a href="lib/internals.html#Internal-API">Internal API</a></li><ul><li><a href="lib/internals.html#Iterating">Iterating</a></li></ul><li><a href="lib/internals.html#Internal-Types">Internal Types</a></li><ul><li><a href="lib/internals.html#Abstract-Parsers">Abstract Parsers</a></li><li><a href="lib/internals.html#States">States</a></li><li><a href="lib/internals.html#Wrapped-Parsers">Wrapped Parsers</a></li><li><a href="lib/internals.html#Printing">Printing</a></li><ul><li><a href="lib/internals.html#PCRE">PCRE</a></li></ul><li><a href="lib/internals.html#Rewriting-Parsers">Rewriting Parsers</a></li></ul></ul><h2 id="main-index"><a class="docs-heading-anchor" href="#main-index">Index</a><a id="main-index-1"></a><a class="docs-heading-anchor-permalink" href="#main-index" title="Permalink"></a></h2><ul><li><a href="lib/public.html#CombinedParsers.match_all"><code>CombinedParsers.match_all</code></a></li><li><a href="lib/public.html#CombinedParsers.parse_all"><code>CombinedParsers.parse_all</code></a></li><li><a href="lib/public.html#CombinedParsers.tryparse_pos"><code>CombinedParsers.tryparse_pos</code></a></li><li><a href="lib/parsers.html#CombinedParsers.DateParser"><code>CombinedParsers.DateParser</code></a></li><li><a href="lib/parsers.html#CombinedParsers.DateTimeParser"><code>CombinedParsers.DateTimeParser</code></a></li><li><a href="lib/parsers.html#CombinedParsers.caseless"><code>CombinedParsers.caseless</code></a></li><li><a href="lib/parsers.html#CombinedParsers.integer_base"><code>CombinedParsers.integer_base</code></a></li><li><a href="lib/parsers.html#CombinedParsers.parser"><code>CombinedParsers.parser</code></a></li><li><a href="lib/parsers.html#CombinedParsers.trim"><code>CombinedParsers.trim</code></a></li><li><a href="lib/parsers.html#CombinedParsers.wrap"><code>CombinedParsers.wrap</code></a></li><li><a href="lib/parsers.html#CombinedParsers.NumericParser"><code>CombinedParsers.NumericParser</code></a></li><li><a href="lib/constructors.html#CombinedParsers.AnyChar"><code>CombinedParsers.AnyChar</code></a></li><li><a href="lib/constructors.html#CombinedParsers.CharIn"><code>CombinedParsers.CharIn</code></a></li><li><a href="lib/constructors.html#CombinedParsers.CharNotIn"><code>CombinedParsers.CharNotIn</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Delayed"><code>CombinedParsers.Delayed</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Lookahead"><code>CombinedParsers.Lookahead</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Lookbehind"><code>CombinedParsers.Lookbehind</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Repeat1"><code>CombinedParsers.Repeat1</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Repeat_stop"><code>CombinedParsers.Repeat_stop</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Repeat_until"><code>CombinedParsers.Repeat_until</code></a></li><li><a href="lib/constructors.html#CombinedParsers._copy"><code>CombinedParsers._copy</code></a></li><li><a href="lib/constructors.html#CombinedParsers._ismatch"><code>CombinedParsers._ismatch</code></a></li><li><a href="lib/constructors.html#CombinedParsers.after"><code>CombinedParsers.after</code></a></li><li><a href="lib/constructors.html#CombinedParsers.defaultvalue"><code>CombinedParsers.defaultvalue</code></a></li><li><a href="lib/constructors.html#CombinedParsers.either_result_type"><code>CombinedParsers.either_result_type</code></a></li><li><a href="lib/constructors.html#CombinedParsers.flatten_valuepatterns"><code>CombinedParsers.flatten_valuepatterns</code></a></li><li><a href="lib/constructors.html#CombinedParsers.ismatch"><code>CombinedParsers.ismatch</code></a></li><li><a href="lib/constructors.html#CombinedParsers.log_names"><code>CombinedParsers.log_names</code></a></li><li><a href="lib/constructors.html#CombinedParsers.log_parser"><code>CombinedParsers.log_parser</code></a></li><li><a href="lib/constructors.html#CombinedParsers.sSequence"><code>CombinedParsers.sSequence</code></a></li><li><a href="lib/constructors.html#CombinedParsers.sequence_result_type"><code>CombinedParsers.sequence_result_type</code></a></li><li><a href="lib/constructors.html#CombinedParsers.sequence_state_type"><code>CombinedParsers.sequence_state_type</code></a></li><li><a href="lib/constructors.html#CombinedParsers.substitute"><code>CombinedParsers.substitute</code></a></li><li><a href="lib/constructors.html#CombinedParsers.with_effect"><code>CombinedParsers.with_effect</code></a></li><li><a href="lib/constructors.html#CombinedParsers.with_log"><code>CombinedParsers.with_log</code></a></li><li><a href="lib/constructors.html#CombinedParsers.with_name"><code>CombinedParsers.with_name</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Always"><code>CombinedParsers.Always</code></a></li><li><a href="lib/constructors.html#CombinedParsers.AnyValue"><code>CombinedParsers.AnyValue</code></a></li><li><a href="lib/constructors.html#CombinedParsers.AtEnd"><code>CombinedParsers.AtEnd</code></a></li><li><a href="lib/constructors.html#CombinedParsers.AtStart"><code>CombinedParsers.AtStart</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Atomic"><code>CombinedParsers.Atomic</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Bytes"><code>CombinedParsers.Bytes</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Either"><code>CombinedParsers.Either</code></a></li><li><a href="lib/constructors.html#CombinedParsers.FlatMap"><code>CombinedParsers.FlatMap</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Lazy"><code>CombinedParsers.Lazy</code></a></li><li><a href="lib/constructors.html#CombinedParsers.MappedSequenceParser"><code>CombinedParsers.MappedSequenceParser</code></a></li><li><a href="lib/constructors.html#CombinedParsers.MemoizingParser"><code>CombinedParsers.MemoizingParser</code></a></li><li><a href="lib/constructors.html#CombinedParsers.NamedParser"><code>CombinedParsers.NamedParser</code></a></li><li><a href="lib/constructors.html#CombinedParsers.NegativeLookahead"><code>CombinedParsers.NegativeLookahead</code></a></li><li><a href="lib/constructors.html#CombinedParsers.NegativeLookbehind"><code>CombinedParsers.NegativeLookbehind</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Never"><code>CombinedParsers.Never</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Optional"><code>CombinedParsers.Optional</code></a></li><li><a href="lib/constructors.html#CombinedParsers.PositiveLookahead"><code>CombinedParsers.PositiveLookahead</code></a></li><li><a href="lib/constructors.html#CombinedParsers.PositiveLookbehind"><code>CombinedParsers.PositiveLookbehind</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Repeat"><code>CombinedParsers.Repeat</code></a></li><li><a href="lib/constructors.html#CombinedParsers.Sequence"><code>CombinedParsers.Sequence</code></a></li><li><a href="lib/constructors.html#CombinedParsers.UnicodeClass"><code>CombinedParsers.UnicodeClass</code></a></li><li><a href="lib/constructors.html#CombinedParsers.ValueIn"><code>CombinedParsers.ValueIn</code></a></li><li><a href="lib/constructors.html#CombinedParsers.ValueMatcher"><code>CombinedParsers.ValueMatcher</code></a></li><li><a href="lib/constructors.html#CombinedParsers.ValueNotIn"><code>CombinedParsers.ValueNotIn</code></a></li><li><a href="lib/constructors.html#CombinedParsers.WithMemory"><code>CombinedParsers.WithMemory</code></a></li><li><a href="lib/transformation.html#CombinedParsers._deepmap"><code>CombinedParsers._deepmap</code></a></li><li><a href="lib/transformation.html#CombinedParsers.deepmap"><code>CombinedParsers.deepmap</code></a></li><li><a href="lib/transformation.html#CombinedParsers.dodeepmap"><code>CombinedParsers.dodeepmap</code></a></li><li><a href="lib/transformation.html#CombinedParsers.infer_result_type"><code>CombinedParsers.infer_result_type</code></a></li><li><a href="lib/transformation.html#CombinedParsers.result_type"><code>CombinedParsers.result_type</code></a></li><li><a href="lib/transformation.html#CombinedParsers.Constant"><code>CombinedParsers.Constant</code></a></li><li><a href="lib/transformation.html#CombinedParsers.IndexAt"><code>CombinedParsers.IndexAt</code></a></li><li><a href="lib/transformation.html#CombinedParsers.MatchRange"><code>CombinedParsers.MatchRange</code></a></li><li><a href="lib/transformation.html#CombinedParsers.MatchedSubSequence"><code>CombinedParsers.MatchedSubSequence</code></a></li><li><a href="lib/transformation.html#CombinedParsers.Transformation"><code>CombinedParsers.Transformation</code></a></li><li><a href="lib/regexp.html#CombinedParsers._iterate-Tuple{ParserWithCaptures, SequenceWithCaptures, Vararg{Any, N} where N}"><code>CombinedParsers._iterate</code></a></li><li><a href="lib/regexp.html#CombinedParsers.regex_escape"><code>CombinedParsers.regex_escape</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.Regcomb"><code>CombinedParsers.Regexp.Regcomb</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.index-Tuple{Subroutine, Any}"><code>CombinedParsers.Regexp.index</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.on_options"><code>CombinedParsers.Regexp.on_options</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.parse_options"><code>CombinedParsers.Regexp.parse_options</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.subroutine_index_reset-Tuple{ParserWithCaptures, Capture}"><code>CombinedParsers.Regexp.subroutine_index_reset</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.with_options"><code>CombinedParsers.Regexp.with_options</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.Backreference"><code>CombinedParsers.Regexp.Backreference</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.Capture"><code>CombinedParsers.Regexp.Capture</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.CharWithOptions"><code>CombinedParsers.Regexp.CharWithOptions</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.Conditional"><code>CombinedParsers.Regexp.Conditional</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.DupSubpatternNumbers"><code>CombinedParsers.Regexp.DupSubpatternNumbers</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.FilterOptions"><code>CombinedParsers.Regexp.FilterOptions</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.MatchingNever"><code>CombinedParsers.Regexp.MatchingNever</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.OnOptionsParser"><code>CombinedParsers.Regexp.OnOptionsParser</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.ParserOptions"><code>CombinedParsers.Regexp.ParserOptions</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.ParserWithCaptures"><code>CombinedParsers.Regexp.ParserWithCaptures</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.SequenceWithCaptures"><code>CombinedParsers.Regexp.SequenceWithCaptures</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.StringWithOptions"><code>CombinedParsers.Regexp.StringWithOptions</code></a></li><li><a href="lib/regexp.html#CombinedParsers.Regexp.Subroutine"><code>CombinedParsers.Regexp.Subroutine</code></a></li><li><a href="lib/internals.html#CombinedParsers._deepmap_parser"><code>CombinedParsers._deepmap_parser</code></a></li><li><a href="lib/internals.html#CombinedParsers._iterate"><code>CombinedParsers._iterate</code></a></li><li><a href="lib/internals.html#CombinedParsers._leftof"><code>CombinedParsers._leftof</code></a></li><li><a href="lib/internals.html#CombinedParsers._rightof"><code>CombinedParsers._rightof</code></a></li><li><a href="lib/internals.html#CombinedParsers.deepmap_parser"><code>CombinedParsers.deepmap_parser</code></a></li><li><a href="lib/internals.html#CombinedParsers.leftof"><code>CombinedParsers.leftof</code></a></li><li><a href="lib/internals.html#CombinedParsers.parsematch_tuple"><code>CombinedParsers.parsematch_tuple</code></a></li><li><a href="lib/internals.html#CombinedParsers.print_constructor"><code>CombinedParsers.print_constructor</code></a></li><li><a href="lib/internals.html#CombinedParsers.regex_inner"><code>CombinedParsers.regex_inner</code></a></li><li><a href="lib/internals.html#CombinedParsers.regex_prefix"><code>CombinedParsers.regex_prefix</code></a></li><li><a href="lib/internals.html#CombinedParsers.regex_string"><code>CombinedParsers.regex_string</code></a></li><li><a href="lib/internals.html#CombinedParsers.regex_suffix"><code>CombinedParsers.regex_suffix</code></a></li><li><a href="lib/internals.html#CombinedParsers.reinfer"><code>CombinedParsers.reinfer</code></a></li><li><a href="lib/internals.html#CombinedParsers.rightof"><code>CombinedParsers.rightof</code></a></li><li><a href="lib/internals.html#CombinedParsers.state_type"><code>CombinedParsers.state_type</code></a></li><li><a href="lib/internals.html#CombinedParsers.strip_either1"><code>CombinedParsers.strip_either1</code></a></li><li><a href="lib/internals.html#CombinedParsers.tuple_pos"><code>CombinedParsers.tuple_pos</code></a></li><li><a href="lib/internals.html#CombinedParsers.tuple_state"><code>CombinedParsers.tuple_state</code></a></li><li><a href="lib/internals.html#CombinedParsers.Assertion"><code>CombinedParsers.Assertion</code></a></li><li><a href="lib/internals.html#CombinedParsers.CombinedParser"><code>CombinedParsers.CombinedParser</code></a></li><li><a href="lib/internals.html#CombinedParsers.ConstantParser"><code>CombinedParsers.ConstantParser</code></a></li><li><a href="lib/internals.html#CombinedParsers.FilterParser"><code>CombinedParsers.FilterParser</code></a></li><li><a href="lib/internals.html#CombinedParsers.LeafParser"><code>CombinedParsers.LeafParser</code></a></li><li><a href="lib/internals.html#CombinedParsers.MatchState"><code>CombinedParsers.MatchState</code></a></li><li><a href="lib/internals.html#CombinedParsers.MatchesIterator"><code>CombinedParsers.MatchesIterator</code></a></li><li><a href="lib/internals.html#CombinedParsers.MemoTreeChildren"><code>CombinedParsers.MemoTreeChildren</code></a></li><li><a href="lib/internals.html#CombinedParsers.NCodeunitsState"><code>CombinedParsers.NCodeunitsState</code></a></li><li><a href="lib/internals.html#CombinedParsers.NIndexParser"><code>CombinedParsers.NIndexParser</code></a></li><li><a href="lib/internals.html#CombinedParsers.NoMatch"><code>CombinedParsers.NoMatch</code></a></li><li><a href="lib/internals.html#CombinedParsers.ParseMatch"><code>CombinedParsers.ParseMatch</code></a></li><li><a href="lib/internals.html#CombinedParsers.WrappedAssertion"><code>CombinedParsers.WrappedAssertion</code></a></li><li><a href="lib/internals.html#CombinedParsers.WrappedParser"><code>CombinedParsers.WrappedParser</code></a></li><li><a href="lib/internals.html#CombinedParsers.Regexp.NoDict"><code>CombinedParsers.Regexp.NoDict</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="man/guide.html">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Monday 16 August 2021 13:23">Monday 16 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
